<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>风月</title>
  
  <subtitle>清如风，明如月</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="/"/>
  <updated>2019-09-24T13:18:18.517Z</updated>
  <id>/</id>
  
  <author>
    <name>风月</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>markdown之数学公式语法</title>
    <link href="/tools-markdown/"/>
    <id>/tools-markdown/</id>
    <published>2019-09-24T13:05:17.000Z</published>
    <updated>2019-09-24T13:18:18.517Z</updated>
    
    <content type="html"><![CDATA[<p>原生hexo并不支持数学公式，需要安装插件 <a href="https://www.mathjax.org/" target="_blank" rel="noopener">mathJax</a>。<a href="https://www.mathjax.org/" target="_blank" rel="noopener">mathJax</a> 是一款运行于浏览器中的开源数学符号渲染引擎，使用 <a href="https://www.mathjax.org/" target="_blank" rel="noopener">mathJax</a> 可以方便的在浏览器中嵌入数学公式。<a href="https://www.mathjax.org/" target="_blank" rel="noopener">mathJax</a> 使用网络字体产生高质量的排版，因此可适应各种分辨率，它的显示是基于文本的而非图片，因此显示效果更好。这些公式可以被搜索引擎使用，因此公式里的符号一样可以被搜索引擎检索到。</p><a id="more"></a><h2 id="行内与独行"><a href="#行内与独行" class="headerlink" title="行内与独行"></a>行内与独行</h2><ol><li>行内公式：将公式插入到本行内，符号：<code>$公式内容$</code>，如：$xyz$</li><li>独行公式：将公式插入到新的一行内，并且居中，符号：<code>$$公式内容$$</code>，如：$$xyz$$</li></ol><h2 id="上标、下标与组合"><a href="#上标、下标与组合" class="headerlink" title="上标、下标与组合"></a>上标、下标与组合</h2><ol><li>上标符号，符号：<code>^</code>，如：$x^4$</li><li>下标符号，符号：<code>_</code>，如：$x_1$</li><li>组合符号，符号：<code>{}</code>，如： ${16} _{8} O {2+} _{2}$</li></ol><h2 id="汉字、字体与格式"><a href="#汉字、字体与格式" class="headerlink" title="汉字、字体与格式"></a>汉字、字体与格式</h2><ol><li>汉字形式，符号：<code>\mbox{}</code>，如：$V_{\mbox{初始}}$</li><li>字体控制，符号：<code>\displaystyle</code>，如：$\displaystyle \frac{x+y}{y+z}$</li><li>下划线符号，符号：<code>\underline</code>，如：$\underline{x+y}$</li><li>标签，符号<code>\tag{数字}</code>，如：$\tag{11}$</li><li>上大括号，符号：<code>\overbrace{算式}</code>，如：$\overbrace{a+b+c+d}^{2.0}$</li><li>下大括号，符号：<code>\underbrace{算式}</code>，如：$a+\underbrace{b+c}_{1.0}+d$</li><li>上位符号，符号：<code>\stacrel{上位符号}{基位符号}</code>，如：$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$</li></ol><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><ol><li>两个quad空格，符号：<code>\qquad</code>，如：$x \qquad y$</li><li>quad空格，符号：<code>\quad</code>，如：$x \quad y$</li><li>大空格，符号<code>\</code>，如：$x \ y$</li><li>中空格，符号<code>\:</code>，如：$x : y$</li><li>小空格，符号<code>\,</code>，如：$x , y$</li><li>没有空格，符号<code></code>，如：$xy$</li><li>紧贴，符号<code>\!</code>，如：$x ! y$</li></ol><h2 id="定界符与组合"><a href="#定界符与组合" class="headerlink" title="定界符与组合"></a>定界符与组合</h2><ol><li>括号，符号：<code>（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)</code>，如：$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</li><li>中括号，符号：<code>[]</code>，如：$[x+y]$</li><li>大括号，符号：<code>\{ \}</code>，如：${x+y}$</li><li>自适应括号，符号：<code>\left \right</code>，如：$\left(x\right)$，$\left(x{yz}\right)$</li><li>组合公式，符号：<code>{上位公式 \choose 下位公式}</code>，如：${n+1 \choose k}={n \choose k}+{n \choose k-1}$</li><li>组合公式，符号：<code>{上位公式 \atop 下位公式}</code>，如：$\sum_{k_0,k_1,\ldots&gt;0 \atop k_0+k_1+\cdots=n}A_{k_0}A_{k_1}\cdots$</li></ol><h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><ol><li>加法运算，符号：<code>+</code>，如：$x+y=z$</li><li>减法运算，符号：<code>-</code>，如：$x-y=z$</li><li>加减运算，符号：<code>\pm</code>，如：$x \pm y=z$</li><li>减甲运算，符号：<code>\mp</code>，如：$x \mp y=z$</li><li>乘法运算，符号：<code>\times</code>，如：$x \times y=z$</li><li>点乘运算，符号：<code>\cdot</code>，如：$x \cdot y=z$</li><li>星乘运算，符号：<code>\ast</code>，如：$x \ast y=z$</li><li>除法运算，符号：<code>\div</code>，如：$x \div y=z$</li><li>斜法运算，符号：<code>/</code>，如：$x/y=z$</li><li>分式表示，符号：<code>\frac{分子}{分母}</code>，如：$\frac{x+y}{y+z}$</li><li>分式表示，符号：<code>{分子} \voer {分母}</code>，如：${x+y} \over {y+z}$</li><li>绝对值表示，符号：<code>||</code>，如：$|x+y|$</li></ol><h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><ol><li>平均数运算，符号：<code>\overline{算式}</code>，如：$\overline{xyz}$</li><li>开二次方运算，符号：<code>\sqrt</code>，如：$\sqrt x$</li><li>开方运算，符号：<code>\sqrt[开方数]{被开方数}</code>，如：$\sqrt[3]{x+y}$</li><li>对数运算，符号：<code>\log</code>，如：$\log(x)$</li><li>极限运算，符号：<code>\lim</code>，如：$\lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>极限运算，符号：<code>\displaystyle \lim</code>，如：$\displaystyle \lim^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\sum</code>，如：$\sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>求和运算，符号：<code>\displaystyle \sum</code>，如：$\displaystyle \sum^{x \to \infty}_{y \to 0}{\frac{x}{y}}$</li><li>积分运算，符号：<code>\int</code>，如：$\int^{\infty}_{0}{xdx}$</li><li>积分运算，符号：<code>\displaystyle \int</code>，如：$\displaystyle \int^{\infty}_{0}{xdx}$</li><li>微分运算，符号：<code>\partial</code>，如：$\frac{\partial x}{\partial y}$</li><li>矩阵表示，符号：<code>\begin{matrix} \end{matrix}</code>，如：$\left[\begin{matrix} 1 &amp;2 &amp;\cdots &amp;4 \5 &amp;6 &amp;\cdots &amp;8 \vdots &amp;\vdots &amp;\ddots &amp;\vdots \13 &amp;14 &amp;\cdots &amp;16\end{matrix} \right]$</li></ol><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ol><li>等于运算，符号：<code>=</code>，如：$x+y=z$</li><li>大于运算，符号：<code>&gt;</code>，如：$x+y&gt;z$</li><li>小于运算，符号：<code>&lt;</code>，如：$x+y&lt;z$</li><li>大于等于运算，符号：<code>\geq</code>，如：$x+y \geq z$</li><li>小于等于运算，符号：<code>\leq</code>，如：$x+y \leq z$</li><li>不等于运算，符号：<code>\neq</code>，如：$x+y \neq z$</li><li>不大于等于运算，符号：<code>\ngeq</code>，如：$x+y \ngeq z$</li><li>不大于等于运算，符号：<code>\not\geq</code>，如：$x+y \not\geq z$</li><li>不小于等于运算，符号：<code>\nleq</code>，如：$x+y \nleq z$</li><li>不小于等于运算，符号：<code>\not\leq</code>，如：$x+y \not\leq z$</li><li>约等于运算，符号：<code>\approx</code>，如：$x+y \approx z$</li><li>恒定等于运算，符号：<code>\equiv</code>，如：$x+y \equiv z$</li></ol><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ol><li>属于运算，符号：<code>\in</code>，如：$x \in y$</li><li>不属于运算，符号：<code>\notin</code>，如：$x \notin y$</li><li>不属于运算，符号：<code>\not\in</code>，如：$x \not\in y$</li><li>子集运算，符号：<code>\subset</code>，如：$x \subset y$</li><li>子集运算，符号：<code>\supset</code>，如：$x \supset y$</li><li>真子集运算，符号：<code>\subseteq</code>，如：$x \subseteq y$</li><li>非真子集运算，符号：<code>\subsetneq</code>，如：$x \subsetneq y$</li><li>真子集运算，符号：<code>\supseteq</code>，如：$x \supseteq y$</li><li>非真子集运算，符号：<code>\supsetneq</code>，如：$x \supsetneq y$</li><li>非子集运算，符号：<code>\not\subset</code>，如：$x \not\subset y$</li><li>非子集运算，符号：<code>\not\supset</code>，如：$x \not\supset y$</li><li>并集运算，符号：<code>\cup</code>，如：$x \cup y$</li><li>交集运算，符号：<code>\cap</code>，如：$x \cap y$</li><li>差集运算，符号：<code>\setminus</code>，如：$x \setminus y$</li><li>同或运算，符号：<code>\bigodot</code>，如：$x \bigodot y$</li><li>同与运算，符号：<code>\bigotimes</code>，如：$x \bigotimes y$</li><li>实数集合，符号：<code>\mathbb{R}</code>，如：<code>\mathbb{R}</code></li><li>自然数集合，符号：<code>\mathbb{Z}</code>，如：<code>\mathbb{Z}</code></li><li>空集，符号：<code>\emptyset</code>，如：$\emptyset$</li></ol><h2 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h2><ol><li>无穷，符号：<code>\infty</code>，如：$\infty$</li><li>虚数，符号：<code>\imath</code>，如：$\imath$</li><li>虚数，符号：<code>\jmath</code>，如：$\jmath$</li><li>数学符号，符号<code>\hat{a}</code>，如：$\hat{a}$</li><li>数学符号，符号<code>\check{a}</code>，如：$\check{a}$</li><li>数学符号，符号<code>\breve{a}</code>，如：$\breve{a}$</li><li>数学符号，符号<code>\tilde{a}</code>，如：$\tilde{a}$</li><li>数学符号，符号<code>\bar{a}</code>，如：$\bar{a}$</li><li>矢量符号，符号<code>\vec{a}</code>，如：$\vec{a}$</li><li>数学符号，符号<code>\acute{a}</code>，如：$\acute{a}$</li><li>数学符号，符号<code>\grave{a}</code>，如：$\grave{a}$</li><li>数学符号，符号<code>\mathring{a}</code>，如：$\mathring{a}$</li><li>一阶导数符号，符号<code>\dot{a}</code>，如：$\dot{a}$</li><li>二阶导数符号，符号<code>\ddot{a}</code>，如：$\ddot{a}$</li><li>上箭头，符号：<code>\uparrow</code>，如：$\uparrow$</li><li>上箭头，符号：<code>\Uparrow</code>，如：$\Uparrow$</li><li>下箭头，符号：<code>\downarrow</code>，如：$\downarrow$</li><li>下箭头，符号：<code>\Downarrow</code>，如：$\Downarrow$</li><li>左箭头，符号：<code>\leftarrow</code>，如：$\leftarrow$</li><li>左箭头，符号：<code>\Leftarrow</code>，如：$\Leftarrow$</li><li>右箭头，符号：<code>\rightarrow</code>，如：$\rightarrow$</li><li>右箭头，符号：<code>\Rightarrow</code>，如：$\Rightarrow$</li><li>底端对齐的省略号，符号：<code>\ldots</code>，如：$1,2,\ldots,n$</li><li>中线对齐的省略号，符号：<code>\cdots</code>，如：$x_1^2 + x_2^2 + \cdots + x_n^2$</li><li>竖直对齐的省略号，符号：<code>\vdots</code>，如：$\vdots$</li><li>斜对齐的省略号，符号：<code>\ddots</code>，如：$\ddots$</li></ol><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alhpa</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>K</td><td><code>K</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>Λ</td><td><code>\Lambda</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>M</td><td><code>M</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>N</td><td><code>N</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td></tr><tr><td>Π</td><td><code>\Pi</code></td><td>π</td><td><code>\pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td></tr><tr><td>Σ</td><td><code>\Sigma</code></td><td>σ</td><td><code>\sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>τ</td><td><code>\tau</code></td></tr><tr><td>Υ</td><td><code>\Upsilon</code></td><td>υ</td><td><code>\upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td></tr><tr><td>X</td><td><code>X</code></td><td>χ</td><td><code>\chi</code></td></tr><tr><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\v</code></td><td>ω</td><td><code>\omega</code></td></tr></tbody></table><h2 id="hexo支持latex语法"><a href="#hexo支持latex语法" class="headerlink" title="hexo支持latex语法"></a>hexo支持latex语法</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-math --save</span><br></pre></td></tr></table></figure><p>在站点配置文件 <em>_config.yml</em> 中添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">math:</span></span><br><span class="line"><span class="attr">  engine:</span> <span class="string">'mathjax'</span></span><br><span class="line"><span class="attr">  mathjax:</span></span><br><span class="line"><span class="attr">    src:</span> <span class="string">"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"</span><span class="string">,</span></span><br><span class="line"><span class="attr">    config:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">      tex2jax:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">        inlineMath:</span> <span class="string">[</span> <span class="string">['$','$'],</span> <span class="string">["\\(","\\)"]</span> <span class="string">],</span></span><br><span class="line"><span class="attr">        skipTags:</span> <span class="string">['script',</span> <span class="string">'noscript'</span><span class="string">,</span> <span class="string">'style'</span><span class="string">,</span> <span class="string">'textarea'</span><span class="string">,</span> <span class="string">'pre'</span><span class="string">,</span> <span class="string">'code'</span><span class="string">],</span></span><br><span class="line"><span class="attr">        processEscapes:</span> <span class="literal">true</span></span><br><span class="line">      <span class="string">&#125;,</span></span><br><span class="line"><span class="attr">      TeX:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">        equationNumbers:</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">          autoNumber:</span> <span class="string">"AMS"</span></span><br><span class="line">        <span class="string">&#125;</span></span><br><span class="line">      <span class="string">&#125;</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>在 next 主题配置文件中 <em>themes/next-theme/_config.yml</em> 中将 mathJax 设为 true:</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/hexojs/hexo-math" target="_blank" rel="noopener">https://github.com/hexojs/hexo-math</a></li><li><a href="http://stevenshi.me/2017/06/26/hexo-insert-formula/" target="_blank" rel="noopener">http://stevenshi.me/2017/06/26/hexo-insert-formula/</a></li><li><a href="https://www.jianshu.com/p/e74eb43960a1" target="_blank" rel="noopener">https://www.jianshu.com/p/e74eb43960a1</a></li><li><a href="http://latex.codecogs.com/eqneditor/editor.php" target="_blank" rel="noopener">http://latex.codecogs.com/eqneditor/editor.php</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原生hexo并不支持数学公式，需要安装插件 &lt;a href=&quot;https://www.mathjax.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mathJax&lt;/a&gt;。&lt;a href=&quot;https://www.mathjax.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mathJax&lt;/a&gt; 是一款运行于浏览器中的开源数学符号渲染引擎，使用 &lt;a href=&quot;https://www.mathjax.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mathJax&lt;/a&gt; 可以方便的在浏览器中嵌入数学公式。&lt;a href=&quot;https://www.mathjax.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mathJax&lt;/a&gt; 使用网络字体产生高质量的排版，因此可适应各种分辨率，它的显示是基于文本的而非图片，因此显示效果更好。这些公式可以被搜索引擎使用，因此公式里的符号一样可以被搜索引擎检索到。&lt;/p&gt;
    
    </summary>
    
      <category term="tools/markdown" scheme="/categories/tools-markdown/"/>
    
    
      <category term="markdown" scheme="/tags/markdown/"/>
    
      <category term="hexo" scheme="/tags/hexo/"/>
    
      <category term="latex" scheme="/tags/latex/"/>
    
  </entry>
  
  <entry>
    <title>HyperLogLog算法</title>
    <link href="/algorithm-HLL/"/>
    <id>/algorithm-HLL/</id>
    <published>2019-09-24T07:53:14.000Z</published>
    <updated>2019-09-24T09:47:18.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基数计数概念"><a href="#基数计数概念" class="headerlink" title="基数计数概念"></a>基数计数概念</h2><p><strong>基数计数(cardinality counting)</strong>：通常用来统计一个集合中不重复的元素个数，例如统计某个网站的UV，或者用户搜索网站的关键词数量。数据分析、网络监控及数据库优化等领域都会涉及到基数计数的需求。 要实现基数计数，最简单的做法是记录集合中所有不重复的元素集合$S_u$，当新来一个元素$x_i$，若$S_u$中不包含元素 $x_i$ ，则将 $x_i$ 加入$S_u$，否则不加入，计数值就是$S_u$的元素数量。这种做法存在两个问题：</p><blockquote><ol><li>当统计的数据量变大时，相应的存储内存也会线性增长</li><li>当集合$S_u$变大，判断其是否包含新加入元素 $x_i$ 的成本变大</li></ol></blockquote><p>大数据量背景下，要实现基数计数，首先需要确定存储统计数据的方案，以及如何根据存储的数据计算基数值；另外还有一些场景下需要融合多个独立统计的基数值，例如对一个网站分别统计了三天的UV，现在需要知道这三天的UV总量是多少，怎么融合多个统计值。</p><a id="more"></a><h2 id="基数计数方法"><a href="#基数计数方法" class="headerlink" title="基数计数方法"></a>基数计数方法</h2><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树最大的优势是插入和查找效率很高，如果用B树存储要统计的数据，可以快速判断新来的数据是否已经存在，并快速将元素插入B树。要计算基数值，只需要计算B树的节点个数。 将B树结构维护到内存中，可以快速统计和计算，但依然存在问题，B树结构只是加快了查找和插入效率，并没有节省存储内存。例如要同时统计几万个链接的UV，每个链接的访问量都很大，如果把这些数据都维护到内存中，实在是够呛。</p><h3 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h3><p>bitmap可以理解为通过一个bit数组来存储特定数据的一种数据结构，每一个bit位都能独立包含信息，bit是数据的最小存储单位，因此能大量节省空间，也可以将整个bit数据一次性load到内存计算。 如果定义一个很大的bit数组，基数统计中每一个元素对应到bit数组的其中一位，例如bit数组 001101001001101001代表实际数组[2,3,5,8]。新加入一个元素，只需要将已有的bit数组和新加入的数字做按位或 (or)计算。bitmap中1的数量就是集合的基数值。</p><p>bitmap有一个很明显的优势是可以轻松合并多个统计结果，只需要对多个结果求异或就可以。也可以大大减少存储内存，可以做个简单的计算，如果要统计1亿个数据的基数值，大约需要内存:100000000/8/1024/1024 ≈ 12M<br>如果用32bit的int代表每个统计数据，大约需要内存：32*100000000/8/1024/1024 ≈ 381M</p><p>bitmap对于内存的节约量是显而易见的，但还是不够。统计一个对象的基数值需要12M，如果统计10000个对象，就需要将近120G了，同样不能广泛用于大数据场景。</p><h3 id="概率算法"><a href="#概率算法" class="headerlink" title="概率算法"></a>概率算法</h3><p>实际上目前还没有发现更好的在大数据场景中准确计算基数的高效算法，因此在不追求绝对准确的情况下，使用概率算法算是一个不错的解决方案。概率算法不直接存储数据集合本身，通过一定的概率统计方法预估基数值，这种方法可以大大节省内存，同时保证误差控制在一定范围内。目前用于基数计数的概率算法包括:</p><ul><li><p><strong>Linear Counting(LC)</strong>：早期的基数估计算法，LC在空间复杂度方面并不算优秀，实际上LC的空间复杂度与简单bitmap方法是一样的（但是有个常数项级别的降低），都是$O(N_\max)$；</p></li><li><p><strong>LogLog Counting(LLC)</strong>：LogLog Counting相比于LC更加节省内存，空间复杂度只有$O(log_2(log_2^\mathrm{N_\max}))$</p></li><li><p><strong>HyperLogLog Counting(HLL)</strong>：HyperLogLog Counting是基于LLC的优化和改进，在同样空间复杂度情况下，能够比LLC的基数估计误差更小。</p></li></ul><h1 id="HLL"><a href="#HLL" class="headerlink" title="HLL"></a>HLL</h1><h3 id="直观演示HLLDEMO"><a href="#直观演示HLLDEMO" class="headerlink" title="直观演示HLLDEMO"></a>直观演示<a href="http://content.research.neustar.biz/blog/hll.html" target="_blank" rel="noopener">HLLDEMO</a></h3><p><img src="/algorithm-HLL/image-20190924162328073.png" alt="image-20190924162352103"></p><h3 id="HLL的实际步骤"><a href="#HLL的实际步骤" class="headerlink" title="HLL的实际步骤"></a>HLL的实际步骤</h3><ol><li>通过hash函数计算输入值对应的比特串</li><li>比特串的低$t(t=log_2^m)$ 位对应的数字用来找到数组<strong>S</strong>中对应的位置 <strong>i</strong></li><li><strong>t+1</strong>位开始找到第一个1出现的位置 <strong>k</strong>，将 <strong>k</strong> 记入数组$S_i$位置</li><li>基于数组<strong>S</strong>记录的所有数据的统计值，计算整体的基数值，计算公式可以简单表示为：$\hat{n}=f(S)$</li></ol><p><strong>HLL</strong>是<strong>LLC</strong>的误差改进，实际是基于<strong>LLC</strong>。</p><h3 id="算法来源（N次伯努利过程）"><a href="#算法来源（N次伯努利过程）" class="headerlink" title="算法来源（N次伯努利过程）"></a>算法来源（N次伯努利过程）</h3><p>下面非正式的从直观角度描述LLC算法的思想来源。</p><p>设<strong>a</strong>为待估集合（哈希后）中的一个元素，由上面对H的定义可知，<strong>a</strong>可以看做一个长度固定的比特串（也就是<strong>a</strong>的二进制表示），设H哈希后的结果长度为L比特，我们将这<strong>L</strong>个比特位从左到右分别编号为<strong>1、2、…、L</strong>：</p><p><img src="/algorithm-HLL/1.png" alt="img"></p><p>又因为<strong>a</strong>是从服从均与分布的样本空间中随机抽取的一个样本，因此<strong>a</strong>每个比特位服从如下分布且相互独立。</p><p>$\rho(x=k) = {^\mathrm{0.5,  k=0}_\mathrm{0.5,  k=1}$</p><p>通俗说就是a的每个比特位为0和1的概率各为0.5，且相互之间是独立的。</p><p>设<strong>ρ(a)</strong>为a的比特串中第一个“1”出现的位置，显然<strong>1≤ρ(a)≤L</strong>，这里我们忽略比特串全为0的情况（概率为$1/2L$ )。如果我们遍历集合中所有元素的比特串，取$\rho_\max$为所有<strong>ρ(a)</strong>的最大值。</p><p>此时我们可以将$2\rho_\max$作为基数的一个粗糙估计，即：$n=2^\mathrm{\rho_\max}$</p><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><p>由于比特串每个比特都独立且服从0-1分布，因此从左到右扫描上述某个比特串寻找第一个“1”的过程从统计学角度看是一个伯努利过程，例如，可以等价看作不断投掷一个硬币（每次投掷正反面概率皆为0.5），直到得到一个正面的过程。在一次这样的过程中，投掷一次就得到正面的概率为1/2，投掷两次得到正面的概率是$1/2^k$，投掷<strong>k</strong>次才得到第一个正面的概率为$1/2^k$。</p><p>现在考虑如下两个问题：</p><p>1、进行n次伯努利过程，所有投掷次数都不大于k的概率是多少？</p><p>2、进行n次伯努利过程，至少有一次投掷次数等于k的概率是多少？</p><p>首先看第一个问题，在一次伯努利过程中，投掷次数大于k的概率为$1/2^k$，即连续掷出k个反面的概率。因此，在一次过程中投掷次数不大于k的概率为$(1 - 1/2^k)$。因此，n次伯努利过程投掷次数均不大于k的概率为：</p><p>$P_n(X \leq k) = (1 - 1/2^k)^n$</p><p>显然第二个问题的答案是：</p><p>$P_n(X \geq k) = 1 - (1 - 1/2^\mathrm{k-1})^n$</p><p>从以上分析可以看出，当$n≪2^k$时，$P_n(X \geq k)$的概率几乎为0，同时，当$n≪2^k$时，$P_n(X \le k)$的概率也几乎为0。用自然语言概括上述结论就是：当伯努利过程次数远远小于时$2^k$，至少有一次过程投掷次数等于k的概率几乎为0；当伯努利过程次数远远大于$2^k$时，没有一次过程投掷次数大于k的概率也几乎为0。</p><p>如果将上面描述做一个对应：一次伯努利过程对应一个元素的比特串，反面对应0，正面对应1，投掷次数k对应第一个“1”出现的位置，我们就得到了下面结论：</p><p>设一个集合的基数为n，$\rho_\max$为所有元素中首个“1”的位置最大的那个元素的“1”的位置，如果n远远小于$2^\mathrm{\rho_\max}$，则我们得到$\rho_\max$为当前值的概率几乎为0（它应该更小），同样的，如果n远远大于$2^\mathrm{\rho_\max}$，则我们得到$\rho_\max$为当前值的概率也几乎为0（它应该更大），因此$2^\mathrm{\rho_\max}$可以作为基数n的一个粗糙估计。</p><p><strong>以上结论可以总结为</strong>：进行了n次进行抛硬币实验，每次分别记录下第一次抛到正面的抛掷次数kk，那么可以用n次实验中最大的抛掷次数$k_\max$ 来预估实验组数量n：$\hat{n}=2^\mathrm{\rho_\max}$ </p><p><img src="/algorithm-HLL/原型图 (1" alt="img">.png)</p><p>回到基数统计的问题，我们需要统计一组数据中不重复元素的个数，集合中每个元素的经过hash函数后可以表示成0和1构成的二进制数串，一个二进制串可以类比为一次抛硬币实验，1是抛到正面，0是反面。二进制串中从低位开始第一个1出现的位置可以理解为抛硬币试验中第一次出现正面的抛掷次数k，那么基于上面的结论，我们可以通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，同样可以可以通过第一个1出现位置的最大值来$k_\max$预估总共有多少个不同的数字（整体基数）。</p><h2 id="LogLogCounting"><a href="#LogLogCounting" class="headerlink" title="LogLogCounting"></a>LogLogCounting</h2><h3 id="均匀随机化"><a href="#均匀随机化" class="headerlink" title="均匀随机化"></a>均匀随机化</h3><p>与LC一样，在使用LLC之前需要选取一个哈希函数H应用于所有元素，然后对哈希值进行基数估计。H必须满足如下条件（定性的）：</p><p>1、H的结果具有很好的均匀性，也就是说无论原始集合元素的值分布如何，其哈希结果的值几乎服从均匀分布（完全服从均匀分布是不可能的，D. Knuth已经证明不可能通过一个哈希函数将一组不服从均匀分布的数据映射为绝对均匀分布，但是很多哈希函数可以生成几乎服从均匀分布的结果，这里我们忽略这种理论上的差异，认为哈希结果就是服从均匀分布）。</p><p>2、H的碰撞几乎可以忽略不计。也就是说我们认为对于不同的原始值，其哈希结果相同的概率非常小以至于可以忽略不计。</p><p>3、H的哈希结果是固定长度的。</p><p>以上对哈希函数的要求是随机化和后续概率分析的基础。后面的分析均认为是针对哈希后的均匀分布数据进行。</p><h3 id="分桶平均"><a href="#分桶平均" class="headerlink" title="分桶平均"></a>分桶平均</h3><p>上述分析给出了LLC的基本思想，不过如果直接使用上面的单一估计量进行基数估计会由于偶然性而存在较大误差。因此，LLC采用了分桶平均的思想来消减误差。具体来说，就是将哈希空间平均分成m份，每份称之为一个桶（bucket）。对于每一个元素，其哈希值的前k比特作为桶编号，其中$2^k = m$ ，而后L-k个比特作为真正用于基数估计的比特串。桶编号相同的元素被分配到同一个桶，在进行基数估计时，首先计算每个桶内元素最大的第一个“1”的位置，设为M[i]，然后对这m个值取平均后再进行估计，即：</p><p>$\hat{n} = 2^\mathrm{1/m}\sum M[i]$</p><p>这相当于物理试验中经常使用的多次试验取平均的做法，可以有效消减因偶然性带来的误差。</p><p>下面举一个例子说明分桶平均怎么做。</p><p>假设H的哈希长度为16bit，分桶数m定为32。设一个元素哈希值的比特串为“0001001010001010”，由于m为32，因此前5个bit为桶编号，所以这个元素应该归入“00010”即2号桶（桶编号从0开始，最大编号为m-1），而剩下部分是“01010001010”且显然ρ(01010001010)=2，所以桶编号为“00010”的元素最大的ρ即为M[2]的值。</p><h3 id="偏差修正"><a href="#偏差修正" class="headerlink" title="偏差修正"></a>偏差修正</h3><p>上述经过分桶平均后的估计量看似已经很不错了，不过通过数学分析可以知道这并不是基数n的无偏估计。因此需要修正成无偏估计。这部分的具体数学分析在“Loglog Counting of Large Cardinalities”中，过程过于艰涩这里不再具体详述，有兴趣的朋友可以参考原论文。</p><h2 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h2><h1 id="HyperLogLog-Counting"><a href="#HyperLogLog-Counting" class="headerlink" title="HyperLogLog Counting"></a>HyperLogLog Counting</h1><p><strong>HyperLogLog Counting</strong>（以下简称<strong>HLLC</strong>）的基本思想也是在<strong>LLC</strong>的基础上做改进，具体细节请参考“HyperLogLog: the analysis of a near-optimal cardinality estimation algorithm”这篇论文。</p><h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><p>HLLC的第一个改进是使用调和平均数替代几何平均数。注意LLC是对各个桶取算数平均数，而算数平均数最终被应用到2的指数上，所以总体来看LLC取得是几何平均数。由于几何平均数对于离群值（例如这里的0）特别敏感，因此当存在离群值时，LLC的偏差就会很大，这也从另一个角度解释了为什么n不太大时LLC的效果不太好。这是因为n较小时，可能存在较多空桶，而这些特殊的离群值强烈干扰了几何平均数的稳定性。</p><p>因此，HLLC使用调和平均数来代替几何平均数，调和平均数的定义如下：</p><p><img src="/algorithm-HLL/image-20190924173124784.png" alt="image-20190924173124784" style="zoom:50%;"></p><p>调和平均数可以有效抵抗离群值的扰动。使用调和平均数代替几何平均数后，估计公式变为如下：</p><p><img src="/algorithm-HLL/image-20190924173155104.png" alt="image-20190924173155104" style="zoom:50%;"></p><p>其中：</p><p><img src="/algorithm-HLL/image-20190924173217926.png" alt="image-20190924173217926" style="zoom:50%;"></p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><h3 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h3><p>这些基数估计算法的一个好处就是非常容易并行化。对于相同分桶数和相同哈希函数的情况，多台机器节点可以独立并行的执行这个算法；最后只要将各个节点计算的同一个桶的最大值做一个简单的合并就可以得到这个桶最终的值。而且这种并行计算的结果和单机计算结果是完全一致的，所需的额外消耗仅仅是小于1k的字节在不同节点间的传输。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>基数估计算法使用很少的资源给出数据集基数的一个良好估计，一般只要使用少于1k的空间存储状态。这个方法和数据本身的特征无关，而且可以高效的进行分布式并行计算。估计结果可以用于很多方面，例如流量监控（多少不同IP访问过一个服务器）以及数据库查询优化（例如我们是否需要排序和合并，或者是否需要构建哈希表）。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基数计数概念&quot;&gt;&lt;a href=&quot;#基数计数概念&quot; class=&quot;headerlink&quot; title=&quot;基数计数概念&quot;&gt;&lt;/a&gt;基数计数概念&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;基数计数(cardinality counting)&lt;/strong&gt;：通常用来统计一个集合中不重复的元素个数，例如统计某个网站的UV，或者用户搜索网站的关键词数量。数据分析、网络监控及数据库优化等领域都会涉及到基数计数的需求。 要实现基数计数，最简单的做法是记录集合中所有不重复的元素集合$S_u$，当新来一个元素$x_i$，若$S_u$中不包含元素 $x_i$ ，则将 $x_i$ 加入$S_u$，否则不加入，计数值就是$S_u$的元素数量。这种做法存在两个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;当统计的数据量变大时，相应的存储内存也会线性增长&lt;/li&gt;
&lt;li&gt;当集合$S_u$变大，判断其是否包含新加入元素 $x_i$ 的成本变大&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;大数据量背景下，要实现基数计数，首先需要确定存储统计数据的方案，以及如何根据存储的数据计算基数值；另外还有一些场景下需要融合多个独立统计的基数值，例如对一个网站分别统计了三天的UV，现在需要知道这三天的UV总量是多少，怎么融合多个统计值。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm/HLL" scheme="/categories/algorithm-HLL/"/>
    
    
      <category term="基数计数" scheme="/tags/%E5%9F%BA%E6%95%B0%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>LZ77压缩算法</title>
    <link href="/algorithm-LZ77/"/>
    <id>/algorithm-LZ77/</id>
    <published>2019-09-19T13:35:17.000Z</published>
    <updated>2019-09-19T13:48:44.945Z</updated>
    
    <content type="html"><![CDATA[<p>　　LZ77算法是无损压缩算法，由以色列人Abraham Lempel发表于1977年。LZ77是典型的基于字典的压缩算法，现在很多压缩技术都是基于LZ77。鉴于其在数据压缩领域的地位，本文将结合图片和源码详细介绍其原理。</p> <a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a><strong>原理</strong></h1><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p><strong>lookahead buffer：</strong>等待编码的区域</p><p><strong>search buffer：</strong>搜索缓冲区</p><p><strong>move window：</strong>滑动窗口，指定大小的窗，包含 “搜索缓冲区”（黄色块） + “待编码区”（绿色块）</p><h2 id="编码过程"><a href="#编码过程" class="headerlink" title="编码过程　　"></a>编码过程　　</h2><p>　　为了编码待编码区， 编码器在滑动窗口的搜索缓冲区查找，直到找到匹配的字符串。匹配字符串的开始字符串与待编码缓冲区的距离称为<code>偏移值</code>，匹配字符串的长度称为<code>匹配长度</code>。编码器在编码时，会一直在搜索区中搜索，直到找到最大匹配字符串，并输出(offset, matchLength )，其中offset是偏移值， matchLength是匹配长度。然后窗口滑动matchLength，继续开始编码。如果没有找到匹配字符串，则输出(0, 0, char)，char为待编码区待编码的字符，窗口滑动1位。算法实现将类似下面的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( lookAheadBuffer <span class="keyword">not</span> empty )</span><br><span class="line">&#123;</span><br><span class="line">    get a pointer (position, match) to the longest match </span><br><span class="line">    <span class="keyword">in</span> the window <span class="keyword">for</span> the lookAheadBuffer;</span><br><span class="line"></span><br><span class="line">    output a (position, length, char());</span><br><span class="line">    shift the window length+<span class="number">1</span> characters along;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>主要步骤为：</strong></p><blockquote><p>1.设置编码位置为输入流的开始</p><p>2.在滑窗的待编码区查找搜索区中的最大匹配字符串</p><p>3.如果找到字符串，输出(偏移值， 匹配长度)， 窗口向前滑动“匹配长度”</p><p>4.如果没有找到，输出(0, 0, 待编码区的第一个字符)，窗口向前滑动一个单位</p><p>5.如果待编码区不为空，回到步骤2</p></blockquote><h2 id="图文讲解"><a href="#图文讲解" class="headerlink" title="图文讲解"></a>图文讲解</h2><p>现在有字符串“AABCBBABC”，现在对其进行编码。</p><p>一开始，窗口滑入如图位置</p><p><img src="/algorithm-LZ77/022016105456631.png" alt="img"></p><p>　　由图可见，待编码缓冲区有“AAB”三个字符，此时搜索缓冲区还是空的。所以编码第一个字符，由于搜索区为空，故找不到匹配串，输出(0,0, A),窗口右移一个单位，如下图</p><p><img src="/algorithm-LZ77/022022065767796.png" alt="img"></p><p>　　此时待编码区有“ABC”。开始编码。最先编码”A”，在搜索区找到”A”。由于没有超过待编码区，故开始编码”AB”，但在搜索区没有找到匹配字符串，故无法编码。因此只能编码”A”。</p><p>输出(1, 1)。即为相对于待编码区，偏移一个单位，匹配长度为1。窗口右滑动匹配长度，即移动1个单位。如下图</p><p><img src="/algorithm-LZ77/022028001558675.png" alt="img"></p><p>一样，没找到，输出(0, 0, B),右移1个单号，如下图</p><p><img src="/algorithm-LZ77/022029151557762.png" alt="img"></p><p>输出（0， 0， C）,右移1个单位，如下图</p><p><img src="/algorithm-LZ77/022030497951749.png" alt="img"></p><p>输出(2, 1),右移1个单位，如下图</p><p><img src="/algorithm-LZ77/022032500457544.png" alt="img"></p><p>输出(3, 1)， 右移1个单位，如下图</p><p>　　<img src="/algorithm-LZ77/022033461551104.png" alt="img"></p><p>　　开始编码”A”，在搜索缓冲区查找到匹配字符串。由于待编码缓冲区没有超过，继续编码。开始编码”AB”,也搜索到。不要停止，继续编码“ABC”，找到匹配字符串。由于继续编码，则超过了窗口，故只编码“ABC”，输出(5, 3),偏移5，长度3。右移3个单位，如下图</p><p>　　<img src="/algorithm-LZ77/022037258738012.png" alt="img"></p><p>此时待编码缓冲区为空，停止编码。</p><p>最终输出结果如下</p><p>　　<img src="/algorithm-LZ77/022038402338227.png" alt="img"></p><p><strong>python代码实现：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lz77</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, inputStr)</span>:</span></span><br><span class="line">        self.inputStr = inputStr <span class="comment">#输入流</span></span><br><span class="line">        self.searchSize = <span class="number">5</span>    <span class="comment">#搜索缓冲区(已编码区)大小</span></span><br><span class="line">        self.aheadSize = <span class="number">3</span>     <span class="comment">#lookAhead缓冲区（待编码区）大小 </span></span><br><span class="line">        self.windSpiltIndex = <span class="number">0</span> <span class="comment">#lookHead缓冲区开始的索引</span></span><br><span class="line">        self.move = <span class="number">0</span></span><br><span class="line">        self.notFind = <span class="number">-1</span>   <span class="comment">#没有找到匹配字符串</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#得到滑动窗口的末端索引</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getWinEndIndex</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.windSpiltIndex + self.aheadSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">#得到滑动窗口的始端索引</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getWinStartIndex</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.windSpiltIndex - self.searchSize</span><br><span class="line"></span><br><span class="line">    <span class="comment">#判断lookHead缓冲区是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isLookHeadEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span> <span class="keyword">if</span> self.windSpiltIndex + self.move&gt; len(self.inputStr) - <span class="number">1</span>   <span class="keyword">else</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encoding</span><span class="params">(self)</span>:</span></span><br><span class="line">        step = <span class="number">0</span></span><br><span class="line">        print(<span class="string">"Step   Position   Match   Output"</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.isLookHeadEmpty():</span><br><span class="line">            <span class="comment">#1.滑动窗口</span></span><br><span class="line">            self.winMove()</span><br><span class="line">            <span class="comment">#2. 得到最大匹配串的偏移值和长度</span></span><br><span class="line">            (offset, matchLen) = self.findMaxMatch()</span><br><span class="line">            <span class="comment">#3.设置窗口下一步需要滑动的距离</span></span><br><span class="line">            self.setMoveSteps(matchLen) </span><br><span class="line">            <span class="keyword">if</span> matchLen == <span class="number">0</span>:</span><br><span class="line">                <span class="comment">#匹配为0，说明无字符串匹配，输出下一个需要编码的字母</span></span><br><span class="line">                nextChar = self.inputStr[self.windSpiltIndex]</span><br><span class="line">                result = (step, self.windSpiltIndex, <span class="string">'-'</span>,  <span class="string">'(0,0)'</span> + nextChar)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = (step, self.windSpiltIndex, self.inputStr[self.windSpiltIndex - offset: self.windSpiltIndex - offset + matchLen], <span class="string">'('</span> + str(offset) + <span class="string">','</span> + str(matchLen) + <span class="string">')'</span>)</span><br><span class="line">            <span class="comment">#4.输出结果</span></span><br><span class="line">            self.output(result)    </span><br><span class="line">            step = step + <span class="number">1</span>        <span class="comment">#仅用来设置第几步</span></span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">    <span class="comment">#滑动窗口(移动分界点)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">winMove</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.windSpiltIndex = self.windSpiltIndex + self.move</span><br><span class="line"></span><br><span class="line">    <span class="comment">#寻找最大匹配字符并返回相对于窗口分界点的偏移值和匹配长度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMaxMatch</span><span class="params">(self)</span>:</span></span><br><span class="line">        matchLen = <span class="number">0</span></span><br><span class="line">        offset = <span class="number">0</span></span><br><span class="line">        minEdge = self.minEdge() + <span class="number">1</span>  <span class="comment">#得到编码区域的右边界</span></span><br><span class="line">        <span class="comment">#遍历待编码区，寻找最大匹配串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.windSpiltIndex + <span class="number">1</span>, minEdge):</span><br><span class="line">            <span class="comment">#print("i: %d" %i)</span></span><br><span class="line">            offsetTemp = self.searchBufferOffest(i)</span><br><span class="line">            <span class="keyword">if</span> offsetTemp == self.notFind: </span><br><span class="line">                <span class="keyword">return</span> (offset, matchLen)</span><br><span class="line">            offset = offsetTemp <span class="comment">#偏移值</span></span><br><span class="line">            </span><br><span class="line">            matchLen = matchLen + <span class="number">1</span>  <span class="comment">#每找到一个匹配串，加1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> (offset, matchLen)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">#入参字符串是否存在于搜索缓冲区，如果存在，返回匹配字符串的起始索引</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBufferOffest</span><span class="params">(self, i)</span>:</span></span><br><span class="line">        searchStart = self.getWinStartIndex()</span><br><span class="line">        searchEnd = self.windSpiltIndex </span><br><span class="line">        <span class="comment">#下面几个if是处理开始时的特殊情况</span></span><br><span class="line">        <span class="keyword">if</span> searchEnd &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> self.notFind</span><br><span class="line">        <span class="keyword">if</span> searchStart &lt; <span class="number">0</span>:</span><br><span class="line">            searchStart = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> searchEnd == <span class="number">0</span>:</span><br><span class="line">                searchEnd = <span class="number">1</span></span><br><span class="line">        searchStr = self.inputStr[searchStart : searchEnd]  <span class="comment">#搜索区字符串</span></span><br><span class="line">        findIndex = searchStr.find(self.inputStr[self.windSpiltIndex : i])</span><br><span class="line">        <span class="keyword">if</span> findIndex == <span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> len(searchStr) - findIndex</span><br><span class="line"></span><br><span class="line">    <span class="comment">#设置下一次窗口需要滑动的步数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setMoveSteps</span><span class="params">(self, matchLen)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> matchLen == <span class="number">0</span>:</span><br><span class="line">            self.move = <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.move = matchLen</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minEdge</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> len(self.inputStr)  <span class="keyword">if</span> len(self.inputStr) - <span class="number">1</span> &lt; self.getWinEndIndex() <span class="keyword">else</span> self.getWinEndIndex() + <span class="number">1</span></span><br><span class="line">         </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">output</span><span class="params">(self, touple)</span>:</span></span><br><span class="line">        print(<span class="string">"%d      %d           %s     %s"</span> % touple)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    lz77 = Lz77(<span class="string">"AABCBBABC"</span>)</span><br><span class="line">    lz77.encoding()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　LZ77算法是无损压缩算法，由以色列人Abraham Lempel发表于1977年。LZ77是典型的基于字典的压缩算法，现在很多压缩技术都是基于LZ77。鉴于其在数据压缩领域的地位，本文将结合图片和源码详细介绍其原理。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm/LZ77" scheme="/categories/algorithm-LZ77/"/>
    
    
      <category term="压缩算法" scheme="/tags/%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95/"/>
    
      <category term="lz77" scheme="/tags/lz77/"/>
    
  </entry>
  
  <entry>
    <title>nginx之proxy</title>
    <link href="/nginx-proxy/"/>
    <id>/nginx-proxy/</id>
    <published>2019-09-12T07:22:26.000Z</published>
    <updated>2019-09-20T03:50:07.276Z</updated>
    
    <content type="html"><![CDATA[<p>最近项目中使用到nginx的反向代理，之前也一直听过nginx的反向代理，但一直没有去详细了解，机会来啦就要抓住，本篇文章将从何为代理到nginx反向代理到最后主要配置指令的详细说明为顺序展开讲解～</p><a id="more"></a><h2 id="为何代理"><a href="#为何代理" class="headerlink" title="为何代理"></a>为何代理</h2><p><strong>正向代理（forward proxy）</strong>：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p><p>有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。</p><p><img src="/nginx-proxy/正向代理.png" alt="正向代理"></p><p><strong>正向代理，其实是”代理服务器”代理了”客户端”，去和”目标服务器”进行交互。</strong></p><p>正向代理的用途：</p><p>1）突破访问限制</p><p>2）提高访问速度</p><p>3）隐藏客户端真实IP</p><p><strong>反向代理（reverse proxy）</strong>：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代。</p><p>用的最多的就是负载均衡，提供web服务的服务器不止一台，一般是一个集群，此时就需要一台统一对外的代理服务器来接收转发相应请求到后端真正处理请求的web服务器上。这个代理服务器一般也叫负载均衡服务器。</p><p><img src="/nginx-proxy/反向代理.png" alt="反向代理"></p><p><strong>反向代理，其实是”代理服务器”代理了”目标服务器”，去和”客户端”进行交互。</strong></p><p>反向代理用途：</p><p>1）隐藏真实服务器IP（一般负载均衡会提供VIP）</p><p>2）负载均衡（平均真实服务器的负载）</p><p>3）提高访问速度（主要是可以缓存部分短时间内重复访问的静态资源）</p><p>4）提供安全保障（可以作为后端服务的防火墙，阻挡部分web攻击，提供访问认证等）</p><p><strong>正向代理和反向代理的区别</strong></p><p>虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。</p><p>1、正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源。反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等。</p><p>2、正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件。而反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器。</p><p>3、正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端。而在反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器。</p><p>4、正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</p><h2 id="Nginx反向代理"><a href="#Nginx反向代理" class="headerlink" title="Nginx反向代理"></a>Nginx反向代理</h2><p>nginx反向代理主要涉及到<code>ngx_http_proxy_module</code>，大部分情况可能会借助<code>ngx_http_upstream_module</code>模块。今天主要讲解这两个模块。</p><p><code>ngx_http_proxy_module</code>模块将请求转发到其他服务器。举个官方🌰：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span>       http://localhost:8000;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host      <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ngx_http_upstream_module</code>模块主要用于定义一组可用于各种pass流向的服务。举个官方🌰</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com       weight=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com:<span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server</span> unix:/tmp/backend3;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server</span> backup1.example.com:<span class="number">8080</span>   backup;</span><br><span class="line">    <span class="attribute">server</span> backup2.example.com:<span class="number">8080</span>   backup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>upstream还可以为每个设备设置状态值，这些状态值的含义分别如下：</p><ul><li>down：表示当前的server暂时不参与负载.</li><li>weight：默认为1。weight越大，负载的权重就越大。</li><li>max_fails：允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误.</li><li>fail_timeout : max_fails次失败后，暂停的时间。</li><li>backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</li></ul><h2 id="配置指令详解"><a href="#配置指令详解" class="headerlink" title="配置指令详解"></a>配置指令详解</h2><h3 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:   proxy_pass URL;</span><br><span class="line">Default:  —</span><br><span class="line">Context:  location, if in location, limit_except</span><br></pre></td></tr></table></figure><p>此指令用于指定web后端服务地址，设置协议、地址和可选URI，格式为：协议(http|https)://+地址+(/URI)，其中地址可以为域名、IP、IP:PORT、Unix Domain Socket以及server group，举个🌰：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#示例1:域名+端口</span></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例2: Unix Domain Socket,这里的domain需要以 "unix:" 开头，以 ":" 结束</span></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://unix:/tmp/backend.socket:/uri/;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#示例3: 地址为server group</span></span><br><span class="line"><span class="attribute">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com       weight=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com:<span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server</span> unix:/tmp/backend3;</span><br><span class="line">    <span class="attribute">server</span> backup1.example.com:<span class="number">8080</span>   backup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果domain被解析为多个地址，这些地址将被循环使用，这可以实现负载均衡了。</p><h4 id="关于URI"><a href="#关于URI" class="headerlink" title="关于URI"></a>关于URI</h4><p>针对设置了URI的情况，原始请求的URI中匹配上location的部分，将被设置中的URI替换，举个🌰：原始URL为 <code>http://domain/proxy/index.html</code> 代理设置的URI为<code>/aaa/</code>，则原URI中的<code>/proxy/</code>将被替换为<code>/aaa/</code>：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配/proxy/ "/proxy/" 将被 "/aaa/"替换</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1/aaa/;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 最终代理到URL：http://127.0.0.1/aaa/test.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#相对于前一种，最后少一个 / ）</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1/aaa;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#代理到URL：http://127.0.0.1/aaatest.html</span></span><br></pre></td></tr></table></figure><p><strong>所以，只要设置了uri，则会将匹配上的部分进行字符串替换。</strong></p><p>如果只设置了domain，没有设置URI，则location匹配到请求中的原始URI会附加在domain后面，作为URI</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设下面四种情况分别用 http://192.168.1.1/proxy/test.html 进行访问。</span></span><br><span class="line"><span class="attribute">location</span> /proxy/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#代理到URL：http://127.0.0.1/proxy/test.html</span></span><br></pre></td></tr></table></figure><h3 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a>proxy_set_header</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax:   proxy_set_header field value;</span><br><span class="line">Default:  proxy_set_header Host $proxy_host;</span><br><span class="line">          <span class="attribute">proxy_set_header</span> Connection close;</span><br><span class="line">Context:  http, server, location</span><br></pre></td></tr></table></figure><p>允许重新定义或者添加发往后端服务器的请求头。其值可以包含文本、变量或者二者的组合，当且仅当当前配置级别中没有定义<code>proxy_set_header</code>指令时，会从上面的级别继承配置。 默认情况下，只有两个请求头会被重新定义。</p><p>关于proxy_set_header功能可以设置反向代理后的http header中的<code>$host</code>,<code>$http_host</code>,<code>$proxy_host</code>，那么这几个有什么区别呢？</p><p>proxy_host：是proxy_pass后面指定的host</p><p>http_host和host：都是原始的host字段，比如请求的地址为<a href="http://www.demo.com，" target="_blank" rel="noopener">www.demo.com，</a> 那么反向代理之后还是<a href="http://www.demo.com" target="_blank" rel="noopener">www.demo.com</a> ，但是如果客户端发送过来的header中没有host字段时，则采用默认的。</p><p>举个🌰：</p><p>客户端（请求web服务）  :    192.168.1.1</p><p>nginx作为反向代理服务器:    192.168.1.136</p><p>nginx作为后端web服务器:    192.168.1.137</p><p>将左侧匹配到的<code>/proxy_path/</code>开头的url全部转发到后端服务器192.168.223.137。</p><p>将136代理服务器，137后端服务器的log_format修改为如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" <span class="variable">$http_host</span> <span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" "<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br></pre></td></tr></table></figure><p>客户端访问<code>http://192.168.1.136:8080/proxy_path/index.html</code></p><h4 id="1-proxy-set-header-Host-host"><a href="#1-proxy-set-header-Host-host" class="headerlink" title="1) proxy_set_header Host $host;"></a>1) proxy_set_header Host $host;</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> <span class="number">192.168.1.136</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~/proxy_path/</span> &#123;</span><br><span class="line">         <span class="attribute">root</span> <span class="string">"/www/html"</span>;</span><br><span class="line">         <span class="attribute">index</span> index.html;</span><br><span class="line">         <span class="attribute">proxy_pass</span> http://192.168.1.137/;</span><br><span class="line">         <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的Host就是对应日志中的http_host。</p><p>查看代理服务器、后端服务器均能在日志中可发现http_host均为192.168.1.136:8080。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192</span><span class="variable">.168</span><span class="variable">.1</span><span class="variable">.1</span> - - [<span class="number">18</span>/Jul/<span class="number">2017</span>:<span class="number">10</span>:<span class="number">21</span>:<span class="number">25</span> +<span class="number">0800</span>] <span class="string">"GET /favicon.ico HTTP/1.1"</span> <span class="number">192</span><span class="variable">.168</span><span class="variable">.1</span><span class="variable">.136</span>:<span class="number">8080</span> <span class="number">404</span> <span class="number">24</span> <span class="string">"http://192.168.1.136:8080/proxy_path/index.html"</span> <span class="string">"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36"</span> <span class="string">"-"</span></span><br></pre></td></tr></table></figure><h4 id="2-proxy-set-header-Host-proxy-host"><a href="#2-proxy-set-header-Host-proxy-host" class="headerlink" title="2) proxy_set_header Host $proxy_host;"></a>2) proxy_set_header Host $proxy_host;</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server_name</span> <span class="number">192.168.1.136</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span><span class="regexp"> ^~/proxy_path/</span> &#123;</span><br><span class="line">         <span class="attribute">root</span> <span class="string">"/www/html"</span>;</span><br><span class="line">         <span class="attribute">index</span> index.html;</span><br><span class="line">         <span class="attribute">proxy_pass</span> http://192.168.1.137/;</span><br><span class="line">         <span class="attribute">proxy_set_header</span> Host <span class="variable">$proxy_host</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先查看136代理服务器的日志：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192</span><span class="variable">.168</span><span class="variable">.1</span><span class="variable">.1</span> - - [<span class="number">18</span>/Jul/<span class="number">2017</span>:<span class="number">10</span>:<span class="number">30</span>:<span class="number">12</span> +<span class="number">0800</span>] <span class="string">"GET /proxy_path/index.html HTTP/1.1"</span> <span class="number">192</span><span class="variable">.168</span><span class="variable">.1</span><span class="variable">.136</span>:<span class="number">8080</span> <span class="number">304</span> <span class="number">0</span> <span class="string">"-"</span> <span class="string">"Mozilla/5.0(Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36"</span> <span class="string">"-"</span></span><br></pre></td></tr></table></figure><p>客户端请求的host为192.168.223.136:8080，而nginx代理服务器作为137后端服务器的客户端，将请求的报文首部重新封装，将proxy_host封装为请求的host。</p><p>那么137上面日志请求的host就是其自身，proxy_host就是代理服务器请求的host，也就是后端服务器137</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192</span><span class="variable">.168</span><span class="variable">.1</span><span class="variable">.136</span> <span class="string">"192.168.1.1"</span> - - [<span class="number">18</span>/Jul/<span class="number">2017</span>:<span class="number">10</span>:<span class="number">30</span>:<span class="number">12</span> +<span class="number">0800</span>] <span class="string">"GET /index.html HTTP/1.0"</span> <span class="string">"192.168.1.137"</span> <span class="number">304</span> <span class="number">0</span> <span class="string">"-"</span> <span class="string">"Mozilla/5.0(Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36"</span> <span class="string">"192.168.1.1"</span></span><br></pre></td></tr></table></figure><p>同理，proxy_port也即为后端服务器137的web端口80。</p><h4 id="3）-X-Real-IP-remote-addr"><a href="#3）-X-Real-IP-remote-addr" class="headerlink" title="3） X-Real-IP $remote_addr;"></a>3） X-Real-IP $remote_addr;</h4><p>将<code>$remote_addr</code>的值放进变量X-Real-IP中，此变量名可变，<code>$remote_addr</code>的值为客户端的ip</p><p>nginx转发136服务器日志格式为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" <span class="variable">$http_host</span> '</span></span><br><span class="line"><span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line"><span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br></pre></td></tr></table></figure><p>nginx后端137服务器的日志格式：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main <span class="string">'<span class="variable">$remote_addr</span> "<span class="variable">$http_x_real_ip</span>" - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" "<span class="variable">$http_host</span>" '</span></span><br><span class="line"><span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line"><span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br></pre></td></tr></table></figure><p>两者区别在于<code>$http_x_real_ip</code>，添加了这个变量的值，通过设置将真实客户端IP传递到了服务端。</p><h4 id="4）X-Forwarded-For-中的-remote-addr-VS-proxy-add-x-forwarded-for"><a href="#4）X-Forwarded-For-中的-remote-addr-VS-proxy-add-x-forwarded-for" class="headerlink" title="4）X-Forwarded-For 中的 $remote_addr VS $proxy_add_x_forwarded_for"></a>4）X-Forwarded-For 中的 <code>$remote_addr</code> VS <code>$proxy_add_x_forwarded_for</code></h4><p><code>$proxy_add_x_forwarded_for</code>变量包含客户端请求头中的”X-Forwarded-For”，与<code>$remote_addr</code>两部分，他们之间用逗号分开。</p><p>举个🌰，135、136、137三台机器均设置为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"><span class="comment">#日志格式</span></span><br><span class="line"><span class="attribute">log_format</span> main <span class="string">'<span class="variable">$remote_addr</span> "<span class="variable">$http_x_real_ip</span>" - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" "<span class="variable">$http_host</span>" '</span></span><br><span class="line"><span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line"><span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br></pre></td></tr></table></figure><p>代理情况如图所示：</p><p><img src="/nginx-proxy/二级代理.png" alt="二级代理"></p><p>135机器上看到的日志中http_x_forwarded_for为真实客户端192.168.1.1，因为此时他的”X-Forwarded-For”部分是空的，所以只有<code>$remote_addr</code></p><p>136机器上看到的日志中http_x_forwarded_for为”192.168.1.1, 192.168.1.135”</p><p>137机器上看到的日志中http_x_forwarded_for为”192.168.1.1, 192.168.1.135, 192.168.1.136”</p><h3 id="proxy-send-timeout"><a href="#proxy-send-timeout" class="headerlink" title="proxy_send_timeout"></a>proxy_send_timeout</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:  proxy_send_timeout time;</span><br><span class="line">Default: proxy_send_timeout 60s;</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><p>设置代理服务器与后端服务器的请求发送超时时间，这个时间只会在连续的两次写操作中生效，如果在此期间后端没有再接收数据，则连接会被断开。</p><h3 id="proxy-read-timeout"><a href="#proxy-read-timeout" class="headerlink" title="proxy_read_timeout"></a>proxy_read_timeout</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:  proxy_read_timeout time;</span><br><span class="line">Default: proxy_read_timeout 60s;</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><p>定义从后端读取数据的超时时间。默认60s</p><h3 id="proxy-set-body"><a href="#proxy-set-body" class="headerlink" title="proxy_set_body"></a>proxy_set_body</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:  proxy_set_body value;</span><br><span class="line">Default: —</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><p>允许重新定义请求体，这里的value可以是文本、变量、或者二者的组合。</p><h3 id="proxy-bind"><a href="#proxy-bind" class="headerlink" title="proxy_bind"></a>proxy_bind</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:  proxy_bind address [transparent] | off;</span><br><span class="line">Default: —</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><p>此指令用于绑定代理后端web服务器收到的请求报文里源ip端口:</p><p>1）如果设定为固定的IP，那么后端真正看到的就是这个固定的IP</p><p>2）如果填写的<code>$remote_addr</code>则看到的是真实client的IP</p><p>3）如果设置为off，则系统会自动设置本机IP和随机指定一个端口</p><p><strong>transparent</strong>：参数的作用是透传客户端IP，使用此参数，在linux上，在1.13.1以下版本需要超级用户权限。</p><p>如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://localhost:8000;</span><br><span class="line">    <span class="attribute">proxy_bind</span> <span class="variable">$remote_addr</span> transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="proxy-next-upstream"><a href="#proxy-next-upstream" class="headerlink" title="proxy_next_upstream"></a>proxy_next_upstream</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:  proxy_next_upstream error | timeout | invalid_header | http_500 | http_502 | http_503 | http_504 | http_403 | http_404 | http_429 | non_idempotent | off ...;</span><br><span class="line">Default: proxy_next_upstream error timeout;</span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure><p>指定在后端返回相应情况下转发到下一台服务器。</p><blockquote><p><strong>error</strong>      ： 和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现错误<br><strong>timeout</strong> ：和后端服务器建立连接时，或者向后端服务器发送请求时，或者从后端服务器接收响应头时，出现超时<br><strong>invalid_header</strong> ： 后端服务器返回空响应或者非法响应头<br><strong>http_500</strong> ： 后端服务器返回的响应状态码为500<br><strong>http_502</strong> ： 后端服务器返回的响应状态码为502<br><strong>http_503</strong> ： 后端服务器返回的响应状态码为503<br><strong>http_504</strong> ： 后端服务器返回的响应状态码为504<br><strong>http_404</strong> ： 后端服务器返回的响应状态码为404<br><strong>off</strong>            ： 停止将请求发送给下一台后端服务器</p></blockquote><p>举个🌰：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_next_upstream</span> http_500 | http_502 | http_503 | http_504 |http_404</span><br></pre></td></tr></table></figure><p>当其中一台服务器返回错误码404,500…等错误时，可以分配到下一台服务器继续处理，提高平台访问成功率，多用于负载均衡。</p><p>针对服务端返回error timeout时，如果采用默认设置，则会继续将请求转发给下一个服务器继续处理。如果请求涉及到充值等情况，有可能被充值多次，此时可以将proxy_next_upstream设置为off。<strong>当然后端服务自己做幂等处理非常有必要。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近项目中使用到nginx的反向代理，之前也一直听过nginx的反向代理，但一直没有去详细了解，机会来啦就要抓住，本篇文章将从何为代理到nginx反向代理到最后主要配置指令的详细说明为顺序展开讲解～&lt;/p&gt;
    
    </summary>
    
      <category term="nginx/proxy" scheme="/categories/nginx-proxy/"/>
    
    
      <category term="nginx" scheme="/tags/nginx/"/>
    
      <category term="proxy" scheme="/tags/proxy/"/>
    
  </entry>
  
  <entry>
    <title>fpm源码之配置解析</title>
    <link href="/php-fpm-02/"/>
    <id>/php-fpm-02/</id>
    <published>2018-09-06T09:51:43.000Z</published>
    <updated>2019-03-05T08:47:14.621Z</updated>
    
    <content type="html"><![CDATA[<p>​    是不是经常在网上看到php-fpm.conf的各种配置项？什么pm.max_children、pm.min_spare_servers、pm.status_path、listen等等。他们到底代表什么意思存放在那个文件里呢？接下来我们就来一探究竟。</p><a id="more"></a><p>在fpm源码初探文章中，我们介绍了源码目录。其中提到两个文件：<code>php-fpm.conf.in</code> 和<code>www.conf.in</code>,这两个文件在安装完php-fpm之后对应的是<code>php-fpm.conf</code>和<code></code>php-fpm.d/<a href="http://www.conf`两个文件。我们具体来看下这两个文件里面的配置指令。" target="_blank" rel="noopener">www.conf`两个文件。我们具体来看下这两个文件里面的配置指令。</a></p><h3 id="php-fpm-conf"><a href="#php-fpm-conf" class="headerlink" title="php-fpm.conf"></a>php-fpm.conf</h3><p>​    存放php-fpm全局配置</p><h4 id="pid："><a href="#pid：" class="headerlink" title="pid："></a>pid：</h4><p>​    此指令用于配置php-fpm运行时主进程的pid存放位置，默认在安装目录的var/run目录下。</p><h4 id="error-log"><a href="#error-log" class="headerlink" title="error_log:"></a>error_log:</h4><p>​    设置fpm日志文件路径，如果设置为syslog，则不会写本地日志文件，会直接发送给syslogd。</p><h4 id="syslog-facility"><a href="#syslog-facility" class="headerlink" title="syslog.facility:"></a>syslog.facility:</h4><p>​    设置日志程序的执行方式，默认daemon，常驻后台类型。</p><h4 id="syslog-ident："><a href="#syslog-ident：" class="headerlink" title="syslog.ident："></a>syslog.ident：</h4><p>​    fpm日志文件前缀，如果有多个fpm运行，可以为每一个单独设置前缀，默认php-fpm</p><h4 id="log-level："><a href="#log-level：" class="headerlink" title="log_level："></a>log_level：</h4><p>​    fpm日志级别，默认notice，可选值：alert, error, warning, notice, debug</p><h4 id="emergency-restart-threshold和emergency-restart-interval"><a href="#emergency-restart-threshold和emergency-restart-interval" class="headerlink" title="emergency_restart_threshold和emergency_restart_interval"></a>emergency_restart_threshold和emergency_restart_interval</h4><p>​    表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过emergency_restart_threshold个php-fpm就会优雅重启。这两个选项一般保持默认值。</p><p>​    <strong>SIGBUS(Bus error)</strong>意味着指针所对应的地址是有效地址，但总线不能正常使用该指针。通常是未对齐的数据访问所致。</p><p>​    <strong>SIGSEGV(Segment fault)</strong>意味着指针所对应的地址是无效地址，没有物理内存对应该地址。</p><h4 id="process-control-timeout"><a href="#process-control-timeout" class="headerlink" title="process_control_timeout"></a>process_control_timeout</h4><p>​    设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0。</p><h4 id="process-max"><a href="#process-max" class="headerlink" title="process.max"></a>process.max</h4><p>​    fpm能够fork的最大进程数，如果设置为0，表示没有限制。主要为fpm的dynamic模式里pool设置。</p><h4 id="process-priority"><a href="#process-priority" class="headerlink" title="process.priority"></a>process.priority</h4><p>​    在使用root账户启动fpm master进程时，设置master进程的优先级。优先级从-19～20，优先级从高到低。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"><span class="comment">; FPM Configuration ;</span></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; All relative paths in this configuration file are relative to PHP's install</span></span><br><span class="line"><span class="comment">; prefix (@prefix@). This prefix can be dynamically changed by using the</span></span><br><span class="line"><span class="comment">; '-p' argument from the command line.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"><span class="comment">; Global Options ;</span></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="comment">; Pid file</span></span><br><span class="line"><span class="comment">; <span class="doctag">Note:</span> the default prefix is @EXPANDED_LOCALSTATEDIR@</span></span><br><span class="line"><span class="comment">; Default Value: none</span></span><br><span class="line"><span class="comment">;pid = run/php-fpm.pid</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Error log file</span></span><br><span class="line"><span class="comment">; If it's set to "syslog", log is sent to syslogd instead of being written</span></span><br><span class="line"><span class="comment">; into a local file.</span></span><br><span class="line"><span class="comment">; <span class="doctag">Note:</span> the default prefix is @EXPANDED_LOCALSTATEDIR@</span></span><br><span class="line"><span class="comment">; Default Value: log/php-fpm.log</span></span><br><span class="line"><span class="comment">;error_log = log/php-fpm.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; syslog_facility is used to specify what type of program is logging the</span></span><br><span class="line"><span class="comment">; message. This lets syslogd specify that messages from different facilities</span></span><br><span class="line"><span class="comment">; will be handled differently.</span></span><br><span class="line"><span class="comment">; See syslog(3) for possible values (ex daemon equiv LOG_DAEMON)</span></span><br><span class="line"><span class="comment">; Default Value: daemon</span></span><br><span class="line"><span class="comment">;syslog.facility = daemon</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; syslog_ident is prepended to every message. If you have multiple FPM</span></span><br><span class="line"><span class="comment">; instances running on the same server, you can change the default value</span></span><br><span class="line"><span class="comment">; which must suit common needs.</span></span><br><span class="line"><span class="comment">; Default Value: php-fpm</span></span><br><span class="line"><span class="comment">;syslog.ident = php-fpm</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Log level</span></span><br><span class="line"><span class="comment">; Possible Values: alert, error, warning, notice, debug</span></span><br><span class="line"><span class="comment">; Default Value: notice</span></span><br><span class="line"><span class="comment">;log_level = notice</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; If this number of child processes exit with SIGSEGV or SIGBUS within the time</span></span><br><span class="line"><span class="comment">; interval set by emergency_restart_interval then FPM will restart. A value</span></span><br><span class="line"><span class="comment">; of '0' means 'Off'.</span></span><br><span class="line"><span class="comment">; Default Value: 0</span></span><br><span class="line"><span class="comment">;emergency_restart_threshold = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Interval of time used by emergency_restart_interval to determine when</span></span><br><span class="line"><span class="comment">; a graceful restart will be initiated.  This can be useful to work around</span></span><br><span class="line"><span class="comment">; accidental corruptions in an accelerator's shared memory.</span></span><br><span class="line"><span class="comment">; Available Units: s(econds), m(inutes), h(ours), or d(ays)</span></span><br><span class="line"><span class="comment">; Default Unit: seconds</span></span><br><span class="line"><span class="comment">; Default Value: 0</span></span><br><span class="line"><span class="comment">;emergency_restart_interval = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Time limit for child processes to wait for a reaction on signals from master.</span></span><br><span class="line"><span class="comment">; Available units: s(econds), m(inutes), h(ours), or d(ays)</span></span><br><span class="line"><span class="comment">; Default Unit: seconds</span></span><br><span class="line"><span class="comment">; Default Value: 0</span></span><br><span class="line"><span class="comment">;process_control_timeout = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; The maximum number of processes FPM will fork. This has been designed to control</span></span><br><span class="line"><span class="comment">; the global number of processes when using dynamic PM within a lot of pools.</span></span><br><span class="line"><span class="comment">; Use it with caution.</span></span><br><span class="line"><span class="comment">; <span class="doctag">Note:</span> A value of 0 indicates no limit</span></span><br><span class="line"><span class="comment">; Default Value: 0</span></span><br><span class="line"><span class="comment">; process.max = 128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Specify the nice(2) priority to apply to the master process (only if set)</span></span><br><span class="line"><span class="comment">; The value can vary from -19 (highest priority) to 20 (lowest priority)</span></span><br><span class="line"><span class="comment">; <span class="doctag">Note:</span> - It will only work if the FPM master process is launched as root</span></span><br><span class="line"><span class="comment">;       - The pool process will inherit the master process priority</span></span><br><span class="line"><span class="comment">;         unless specified otherwise</span></span><br><span class="line"><span class="comment">; Default Value: no set</span></span><br><span class="line"><span class="comment">; process.priority = -19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Send FPM to background. Set to 'no' to keep FPM in foreground for debugging.</span></span><br><span class="line"><span class="comment">; Default Value: yes</span></span><br><span class="line"><span class="comment">;daemonize = yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Set open file descriptor rlimit for the master process.</span></span><br><span class="line"><span class="comment">; Default Value: system defined value</span></span><br><span class="line"><span class="comment">;rlimit_files = 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Set max core size rlimit for the master process.</span></span><br><span class="line"><span class="comment">; Possible Values: 'unlimited' or an integer greater or equal to 0</span></span><br><span class="line"><span class="comment">; Default Value: system defined value</span></span><br><span class="line"><span class="comment">;rlimit_core = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Specify the event mechanism FPM will use. The following is available:</span></span><br><span class="line"><span class="comment">; - select     (any POSIX os)</span></span><br><span class="line"><span class="comment">; - poll       (any POSIX os)</span></span><br><span class="line"><span class="comment">; - epoll      (linux &gt;= 2.5.44)</span></span><br><span class="line"><span class="comment">; - kqueue     (FreeBSD &gt;= 4.1, OpenBSD &gt;= 2.9, NetBSD &gt;= 2.0)</span></span><br><span class="line"><span class="comment">; - /dev/poll  (Solaris &gt;= 7)</span></span><br><span class="line"><span class="comment">; - port       (Solaris &gt;= 10)</span></span><br><span class="line"><span class="comment">; Default Value: not set (auto detection)</span></span><br><span class="line"><span class="comment">;events.mechanism = epoll</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; When FPM is built with systemd integration, specify the interval,</span></span><br><span class="line"><span class="comment">; in seconds, between health report notification to systemd.</span></span><br><span class="line"><span class="comment">; Set to 0 to disable.</span></span><br><span class="line"><span class="comment">; Available Units: s(econds), m(inutes), h(ours)</span></span><br><span class="line"><span class="comment">; Default Unit: seconds</span></span><br><span class="line"><span class="comment">; Default value: 10</span></span><br><span class="line"><span class="comment">;systemd_interval = 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"><span class="comment">; Pool Definitions ;</span></span><br><span class="line"><span class="comment">;;;;;;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Multiple pools of child processes may be started with different listening</span></span><br><span class="line"><span class="comment">; ports and different management options.  The name of the pool will be</span></span><br><span class="line"><span class="comment">; used in logs and stats. There is no limitation on the number of pools which</span></span><br><span class="line"><span class="comment">; FPM can handle. Your system will tell you anyway :)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Include one or more files. If glob(3) exists, it is used to include a bunch of</span></span><br><span class="line"><span class="comment">; files from a glob(3) pattern. This directive can be used everywhere in the</span></span><br><span class="line"><span class="comment">; file.</span></span><br><span class="line"><span class="comment">; Relative path can also be used. They will be prefixed by:</span></span><br><span class="line"><span class="comment">;  - the global prefix if it's been set (-p argument)</span></span><br><span class="line"><span class="comment">;  - @prefix@ otherwise</span></span><br><span class="line"><span class="attr">include</span>=@php_fpm_sysconfdir@/php-fpm.d/*.conf</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    是不是经常在网上看到php-fpm.conf的各种配置项？什么pm.max_children、pm.min_spare_servers、pm.status_path、listen等等。他们到底代表什么意思存放在那个文件里呢？接下来我们就来一探究竟。&lt;/p&gt;
    
    </summary>
    
      <category term="php/fpm/02" scheme="/categories/php-fpm-02/"/>
    
    
      <category term="fpm" scheme="/tags/fpm/"/>
    
      <category term="源码" scheme="/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="php" scheme="/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>fpm源码之初探【原创】</title>
    <link href="/php-fpm-01/"/>
    <id>/php-fpm-01/</id>
    <published>2018-07-23T16:00:00.000Z</published>
    <updated>2018-09-06T09:56:54.611Z</updated>
    
    <content type="html"><![CDATA[<p>本文在php-7.2.0版本下进行分析。主要介绍fpm目录文件，并介绍fpm入口文件。</p><a id="more"></a><h1 id="1、fpm目录"><a href="#1、fpm目录" class="headerlink" title="1、fpm目录"></a>1、fpm目录</h1><p>fpm位于<code>php_src/sapi</code>目录下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CREDITS //fpm名称和贡献者列表</span><br><span class="line">├── LICENSE //声明</span><br><span class="line">├── Makefile.frag //make时使用的文件</span><br><span class="line">├── config.m4 //构建fpm扩展的配置文件</span><br><span class="line">├── fpm //fpm源码目录</span><br><span class="line">├── init.d.php-fpm.in //fpm提供给init.d程序使用的配置</span><br><span class="line">├── php-fpm.8.in </span><br><span class="line">├── php-fpm.conf.in //fpm运行时的配置文件</span><br><span class="line">├── php-fpm.service.in //fpm提供给systemd管理时使用的配置</span><br><span class="line">├── status.html.in // fpm运行时状态查看页面</span><br><span class="line">├── tests //测试fpm的脚本</span><br><span class="line">└── www.conf.in //fpm运行时配置，这个主要是pool池配置管理</span><br></pre></td></tr></table></figure><p>linux管理进程有两种常见方式，centOS7以下，基本采用init.d来管理操作系统的启动，而centOS7开始使用systemd来管理系统的启动，关于这两种启动方式，超出本文所讲述的范围，这里只给出相关链接。systemd，阮一峰老师的一篇文章，讲解的非常浅显易懂，<a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="noopener">Systemd入门</a>。init这里没有找到比较好的，给出维基百科的解释。<a href="https://zh.wikipedia.org/wiki/Init" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/Init</a></p><p>之所以要提及init和systemd，主要是在我们的fpm目录下，为这两个程序提供了相应的管理配置。具体配置这里不展开详述了，感兴趣的可以了解相关资料。</p><h2 id="fpm目录"><a href="#fpm目录" class="headerlink" title="fpm目录"></a>fpm目录</h2><p>存放fpm源码的目录，fpm采用c语言编写，每个文件都是成对出现的，<code>.c</code>和<code>.h</code>文件，其详细结构如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">php-7.2.0/sapi/fpm</span><br><span class="line">.</span><br><span class="line">├── events //fpm事件处理相关源码</span><br><span class="line">│   ├── devpoll.c</span><br><span class="line">│   ├── devpoll.h</span><br><span class="line">│   ├── epoll.c</span><br><span class="line">│   ├── epoll.h</span><br><span class="line">│   ├── kqueue.c</span><br><span class="line">│   ├── kqueue.h</span><br><span class="line">│   ├── poll.c</span><br><span class="line">│   ├── poll.h</span><br><span class="line">│   ├── port.c</span><br><span class="line">│   ├── port.h</span><br><span class="line">│   ├── select.c</span><br><span class="line">│   └── select.h</span><br><span class="line">├── fpm.c //fpm主程序实现</span><br><span class="line">├── fpm.h //fpm主程序头文件</span><br><span class="line">├── fpm_arrays.h //fpm数组相关</span><br><span class="line">├── fpm_atomic.h //fpm原子操作相关</span><br><span class="line">├── fpm_children.c //fpm子进程相关</span><br><span class="line">├── fpm_children.h </span><br><span class="line">├── fpm_cleanup.c </span><br><span class="line">├── fpm_cleanup.h //fpm内存清理</span><br><span class="line">├── fpm_clock.c</span><br><span class="line">├── fpm_clock.h //fpm时钟管理</span><br><span class="line">├── fpm_conf.c</span><br><span class="line">├── fpm_conf.h //fpm运行时配置解析，包括运行方式、进程池等的配置</span><br><span class="line">├── fpm_config.h //fpm计数器配置</span><br><span class="line">├── fpm_env.c</span><br><span class="line">├── fpm_env.h //fpm环境变量</span><br><span class="line">├── fpm_events.c</span><br><span class="line">├── fpm_events.h //fpm事件处理相关</span><br><span class="line">├── fpm_log.c</span><br><span class="line">├── fpm_log.h //fpm日志相关</span><br><span class="line">├── fpm_main.c //fpm入口文件</span><br><span class="line">├── fpm_php.c</span><br><span class="line">├── fpm_php.h //fpm中php与zend的中间交互</span><br><span class="line">├── fpm_php_trace.c</span><br><span class="line">├── fpm_php_trace.h //fpm执行栈</span><br><span class="line">├── fpm_process_ctl.c</span><br><span class="line">├── fpm_process_ctl.h //fpm进程控制</span><br><span class="line">├── fpm_request.c </span><br><span class="line">├── fpm_request.h //fpm请求处理</span><br><span class="line">├── fpm_scoreboard.c</span><br><span class="line">├── fpm_scoreboard.h //fpm的计数器，主要用于管理work</span><br><span class="line">├── fpm_shm.c</span><br><span class="line">├── fpm_shm.h //fpm共享内存分配处理</span><br><span class="line">├── fpm_signals.c</span><br><span class="line">├── fpm_signals.h //fpm信号处理</span><br><span class="line">├── fpm_sockets.c </span><br><span class="line">├── fpm_sockets.h //fpm套接字处理</span><br><span class="line">├── fpm_status.c</span><br><span class="line">├── fpm_status.h //fpm状态管理</span><br><span class="line">├── fpm_stdio.c</span><br><span class="line">├── fpm_stdio.h //fpm输入输出管理</span><br><span class="line">├── fpm_str.h //fpm字符串复制</span><br><span class="line">├── fpm_systemd.c </span><br><span class="line">├── fpm_systemd.h //fpm与systemd通信管理</span><br><span class="line">├── fpm_trace.c</span><br><span class="line">├── fpm_trace.h //fpm调用栈相关</span><br><span class="line">├── fpm_trace_mach.c //fpm master进程检测相关</span><br><span class="line">├── fpm_trace_pread.c //fpm进程状态检测相关</span><br><span class="line">├── fpm_trace_ptrace.c</span><br><span class="line">├── fpm_unix.c</span><br><span class="line">├── fpm_unix.h //处理unix文件系统相关</span><br><span class="line">├── fpm_worker_pool.c</span><br><span class="line">├── fpm_worker_pool.h //fpm 工作进程池相关</span><br><span class="line">├── zlog.c</span><br><span class="line">└── zlog.h //fpm日志记录</span><br></pre></td></tr></table></figure><h2 id="fpm入口程序"><a href="#fpm入口程序" class="headerlink" title="fpm入口程序"></a>fpm入口程序</h2><p><strong>FPM(FastCGI Process Manager)</strong>是PHP FastCGI运行模式的一个进程管理器，从它的定义可以看出，FPM的核心功能是进程管理，那么它用来管理什么进程呢？接下来我们将从入口程序开始，一点一点揭开其神秘面纱。分析一个程序，找准入口是关键，找到入口后根据主脉络往下捋即可。按照这样的指导思想，那我们就开始吧。</p><p><strong>php_src/sapi/fpm/fpm/fpm_main.c：</strong>fpm入口程序，找到main入口函数，我们先来看下fpm启动执行的主要流程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//注册SAPI:将全局变量sapi_module设置为cgi_sapi_module</span></span><br><span class="line">    sapi_startup(&amp;cgi_sapi_module);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//执行php_module_starup()</span></span><br><span class="line">    <span class="keyword">if</span> (cgi_sapi_module.startup(&amp;cgi_sapi_module) == FAILURE) &#123;</span><br><span class="line">        <span class="keyword">return</span> FPM_EXIT_SOFTWARE;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &gt; fpm_init(...))&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    fpm_is_running = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    fcgi_fd = fpm_run(&amp;max_requests);<span class="comment">//后面都是worker进程的操作，master进程不会走到下面，因为在fpm_run中已经根据work_pool进行子进程fork了</span></span><br><span class="line">    parent = <span class="number">0</span>;</span><br><span class="line">    ...</span><br><span class="line">request = fpm_init_request(fcgi_fd);<span class="comment">//初始化请求，开辟内存空间、设置请求相关的环境变量、绑定socket等</span></span><br><span class="line">zend_first_try &#123;<span class="comment">//开始一个try</span></span><br><span class="line">        <span class="keyword">while</span> (EXPECTED(fcgi_accept_request(request) &gt;= <span class="number">0</span>)) &#123;<span class="comment">//阻塞等待请求到来，关于fpm如何接受请求，后面会有文章专门讲解</span></span><br><span class="line">            ...</span><br><span class="line">            init_request_info();<span class="comment">//初始化请求结构，包括PATH_INFO、SCRIPT_NAME、REQUEST_URI、SCRIPT_FILENAME等</span></span><br><span class="line">            fpm_request_info();<span class="comment">//将cgi中的请求信息复制到fpm请求中</span></span><br><span class="line">            php_request_startup()<span class="comment">//php请求处理开始</span></span><br><span class="line">            fpm_status_handle_request()<span class="comment">//处理fpm启动后状态检测，如果状态不太对，就跳过后面的处理，结束请求</span></span><br><span class="line">            ...</span><br><span class="line">            php_fopen_primary_script(&amp;file_handle)<span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            fpm_request_executing();<span class="comment">//请求执行</span></span><br><span class="line">            php_execute_script(&amp;file_handle);<span class="comment">//执行脚本</span></span><br><span class="line">            ...</span><br><span class="line">            fpm_request_end();<span class="comment">//请求执行结束</span></span><br><span class="line">            php_request_shutdown((<span class="keyword">void</span> *) <span class="number">0</span>);<span class="comment">//请求关闭</span></span><br><span class="line">            ...</span><br><span class="line">            requests++;</span><br><span class="line">            <span class="keyword">if</span> (UNEXPECTED(max_requests &amp;&amp; (requests == max_requests))) &#123;<span class="comment">//判断一个子进程处理的请求数，如果达到处理上线就光荣退出</span></span><br><span class="line">                fcgi_request_set_keep(request, <span class="number">0</span>);</span><br><span class="line">                fcgi_finish_request(request, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ...</span><br><span class="line">    &#125;</span><br><span class="line">        fcgi_destroy_request(request);<span class="comment">//销毁fpm请求</span></span><br><span class="line">fcgi_shutdown();<span class="comment">//fcgi关闭</span></span><br><span class="line">&#125; zend_catch &#123;</span><br><span class="line">exit_status = FPM_EXIT_SOFTWARE;</span><br><span class="line">&#125; zend_end_try();</span><br><span class="line">    </span><br><span class="line">    php_module_shutdown();<span class="comment">//关闭模块</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> exit_status;<span class="comment">//进程退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一些入口文件干的事情：</p><ol><li>初始化数据结构</li><li>解析命令行参数</li><li>初始化fpm_init</li><li>执行fpm_run</li><li>启动监听端口并处理请求（此处主进程是不会走到的）</li></ol><p>下面一篇文章将会讲解fpm的进程是如何管理的</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文在php-7.2.0版本下进行分析。主要介绍fpm目录文件，并介绍fpm入口文件。&lt;/p&gt;
    
    </summary>
    
      <category term="php/fpm/01" scheme="/categories/php-fpm-01/"/>
    
    
      <category term="PHP" scheme="/tags/PHP/"/>
    
      <category term="源码分析" scheme="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="fpm" scheme="/tags/fpm/"/>
    
  </entry>
  
  <entry>
    <title>fpm源码解析准备【原创】</title>
    <link href="/php-fpm/"/>
    <id>/php-fpm/</id>
    <published>2018-07-22T16:00:00.000Z</published>
    <updated>2019-03-05T08:47:20.064Z</updated>
    
    <content type="html"><![CDATA[<p>​    之前看过网上零散的关于php-fpm分析的文章，要么不全，要么就是讲解php-fpm的配置文件的，还有就是讲解nginx与php-fpm之间通信配置的。关于php-fpm中的进程管理、信号管理、事件处理、时钟管理、请求处理等几乎为零。故本着学习的宗旨对fpm源码进行解读。本系列采用php-7.2.0版本中的php-fpm进行分系列讲解。本系列共分为5节，具体如下：</p><a id="more"></a><ol><li><a href="http://xwxz.github.io/php-fpm-01/#more" target="_blank" rel="noopener">fpm源码之初探</a></li><li><a href="">fpm源码之配置解析</a></li><li><a href="">fpm源码之进程管理</a></li><li><a href="">fpm源码之信号处理</a></li><li><a href="">fpm源码之事件管理</a></li><li><a href="">fpm源码之请求处理</a></li></ol><p>源码地址：<a href="https://github.com/php/php-src" target="_blank" rel="noopener">https://github.com/php/php-src</a></p><h2 id="源码查看工具"><a href="#源码查看工具" class="headerlink" title="源码查看工具"></a>源码查看工具</h2><p>sublime+vim</p><h2 id="什么是-Zend-什么是-PHP"><a href="#什么是-Zend-什么是-PHP" class="headerlink" title="什么是 Zend ? 什么是 PHP ?"></a>什么是 Zend ? 什么是 PHP ?</h2><p><em>Zend</em>是语言引擎，PHP内核。PHP是从外层展现的完整系统。咋一听似乎有点模糊不清，但是其实并不复杂，为了实现一个 web 脚本解释器，你需要三个部分：</p><ol><li>第一：<strong>解释器部分</strong> 分析输入代码，翻译代码，然后执行代码。</li><li>第二：<strong>功能部分</strong> 完成语言的功能（函数，等等）。</li><li>第三：<strong>接口部分</strong> 与web通信</li></ol><p><img src="http://php.net/manual/zh/images/befd863081615f539082d9ff76bf7b39-zend.01-internal-structure.png" alt="img"></p><h2 id="组成扩展的文件"><a href="#组成扩展的文件" class="headerlink" title="组成扩展的文件"></a>组成扩展的文件</h2><p>经过上面的复习，我们知道PHP由三部分组成，其中最容易扩展的就是modules部分，而fpm也是以php扩展的形式存在的，那么在开始讲解fpm源码之前，我简单介绍下php扩展。这里参考的是<a href="http://php.net/manual/zh/internals2.structure.php" target="_blank" rel="noopener">官方文档</a></p><p>不管通过什么方式创建的扩展，都至少包含以下四个文件：</p><p><strong>config.m4</strong></p><pre><code>unix构建系统配置 [参考](http://php.net/manual/zh/internals2.buildsys.configunix.php)</code></pre><p><strong>config.w32</strong></p><pre><code>windows构建系统配置</code></pre><p><strong>php_xxx.h</strong></p><pre><code>xxx为扩展名字，当将扩展作为静态模块构建并放入PHP二进制包时，构建系统会要求用php_加扩展的名称命名的头文件包含一个对扩展模块结构的指针定义。就像其他头文件，此文件经常包含附加的宏、原型和全局变量。</code></pre><p><strong>xxx.c</strong></p><pre><code>主要的扩展源文件。按惯例，此文件名就是扩展的名称，比如这里的xxx，但不是必需的。此文件包含模块结构定义、INI条目、管理函数、用户空间函数和其他扩展所需的内容。</code></pre><p>扩展应包含任意数量的头文件、源文件、单元测试和其他支持文件。此四个文件仅够组成最小的扩展。</p><p>比如通过php源文件中<code>$path/php-7.2.0/ext/ext_skel</code>命令生成的xxx扩展，其目录如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CREDITS //纯文本格式列出了扩展的贡献者和（或 ）维护者</span><br><span class="line">├── EXPERIMENTAL</span><br><span class="line">├── config.m4</span><br><span class="line">├── config.w32</span><br><span class="line">├── php_xxx.h</span><br><span class="line">├── tests //测试扩展的测试文件，php扩展使用php来测试</span><br><span class="line">│   └── 001.phpt</span><br><span class="line">├── xxx.c</span><br><span class="line">└── xxx.php</span><br></pre></td></tr></table></figure><p>其中<strong>xxx.php</strong>内容如下，主要用于测试扩展：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$br = (php_sapi_name() == <span class="string">"cli"</span>)? <span class="string">""</span>:<span class="string">"&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!extension_loaded(<span class="string">'xxx'</span>)) &#123;</span><br><span class="line">dl(<span class="string">'xxx.'</span> . PHP_SHLIB_SUFFIX);</span><br><span class="line">&#125;</span><br><span class="line">$module = <span class="string">'xxx'</span>;</span><br><span class="line">$functions = get_extension_funcs($module);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Functions available in the test extension:$br\n"</span>;</span><br><span class="line"><span class="keyword">foreach</span>($functions <span class="keyword">as</span> $func) &#123;</span><br><span class="line">    <span class="keyword">echo</span> $func.<span class="string">"$br\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$br\n"</span>;</span><br><span class="line">$function = <span class="string">'confirm_'</span> . $module . <span class="string">'_compiled'</span>;</span><br><span class="line"><span class="keyword">if</span> (extension_loaded($module)) &#123;</span><br><span class="line">$str = $function($module);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">$str = <span class="string">"Module $module is not compiled into PHP"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">"$str\n"</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="C语言基础知识复习"><a href="#C语言基础知识复习" class="headerlink" title="C语言基础知识复习"></a>C语言基础知识复习</h2><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><p>用在变量或函数的声明前，用来说明”此变量/函数是在别处定义的，要在此处引用”。</p><p>对变量而言，变量的声明有两种情况：</p><p>1、 一种是需要建立存储空间的，不用加extern；</p><p>2、另一种是不需要建立存储空间，需要加extern 。如果你想在本源文件中使用另一个源文件的变量，就需要在使用前用extern声明该变量，或者在头文件中用extern声明该变量；</p><p>举例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;<span class="comment">//声明一个全局变量a</span></span><br><span class="line"><span class="keyword">int</span> a; <span class="comment">//定义一个全局变量a</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a =<span class="number">0</span> ;<span class="comment">//定义一个全局变量a 并给初值</span></span><br><span class="line"><span class="keyword">int</span> a =<span class="number">0</span>;<span class="comment">//定义一个全局变量a,并给初值</span></span><br></pre></td></tr></table></figure><p>注意变量定义智能出现在一处，而外部引用声明可以出现多次。</p><p>对函数而言，如果你想在本源文件中使用另一个源文件的函数，就需要在使用前用声明该函数，声明函数加不加extern都没关系，所以在头文件中函数可以不用加extern。</p><h3 id="memset"><a href="#memset" class="headerlink" title="memset"></a>memset</h3><p><strong>内存申请并初始化函数</strong>：将s所指向的某一块内存中的后n个字节的内容全部设置为ch指定的ASCII值，第一个值为指定的内存地址，块的大小由第三个参数决定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span><span class="params">(<span class="keyword">void</span> *s, <span class="keyword">int</span> ch, <span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p><strong>动态内存分配：</strong>全称是memory allocation，用于申请一块连续的指定大小的内存块区域以<code>void*</code>类型返回分配的内存区域地址。其中<code>void*</code>表示未确定类型的指针。其可以通过类型转换强制转换为任何其他类型的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p><strong>指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。</strong></p><p>我们指知道：C语言中的数组是指 一类 类型，数组具体区分为  int 类型数组，double类型数组,char数组 等等。同样指针 这个概念也泛指 一类 数据类型，int指针类型，double指针类型，char指针类型等等。</p><p>通常，我们用int类型保存一些整型的数据，如 int num = 97 ， 我们也会用char来存储字符： char ch = ‘a’。</p><p>我们也必须知道：任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p><h3 id="void-类型指针"><a href="#void-类型指针" class="headerlink" title="void *类型指针"></a>void *类型指针</h3><p>由于void是空类型，因此<code>void *</code>类型的指针只保存了指针的值，而丢失了类型信息，我们不知道他指向的数据是什么类型的，只指定这个数据在内存中的起始地址，如果想要完整的提取指向的数据，程序员就必须对这个指针做出正确的类型转换，然后再解指针。因为，编译器不允许直接对<code>void *</code>类型的指针做解指针操作。</p><h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><p>struct为结构体关键字，tag为结构体的标志，member-list为结构体成员列表，其必须列出其所有成员；variable-list为此结构体声明的变量。结构体的2种定义方式：</p><p><strong>常规定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> //结构体定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">int</span>score[<span class="number">5</span>];</span><br><span class="line">&#125;；</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">s1</span> = &#123;</span><span class="string">"zhangsan"</span>,<span class="number">22</span>,&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">10</span>&#125;&#125;; <span class="comment">//结构体变量声明并初始化</span></span><br></pre></td></tr></table></figure><p><strong>尾部定义</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>name[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>age;</span><br><span class="line"><span class="keyword">int</span>score[<span class="number">5</span>];</span><br><span class="line">&#125;stu1 = &#123;<span class="string">"张三"</span>,<span class="number">20</span>,&#123;<span class="number">150</span>,<span class="number">110</span>,<span class="number">20</span>,<span class="number">34</span>,<span class="number">114</span>&#125;&#125;，stu2; <span class="comment">//匿名结构体定义时声明变量并初始化</span></span><br></pre></td></tr></table></figure><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p><strong>1. static全局变量</strong></p><p>我们知道，一个进程在内存中的布局如图所示：</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1ftl178ha0pj305o0iyt8t.jpg" alt=""></p><pre><code>其中.text段保存进程所执行的程序二进制文件，.data段保存进程所有的已初始化的全局变量，.bss段保存进程未初始化的全局变量（其他段中还有很多乱七八糟的段，暂且不表）。在进程的整个生命周期中，.data段和.bss段内的数据时跟整个进程同生共死的，也就是在进程结束之后这些数据才会寿终就寝。当一个进程的全局变量被声明为static之后，它的中文名叫**静态全局变量**。静态全局变量和其他的全局变量的存储地点并没有区别，都是在.data段（已初始化）或者.bss段（未初始化）内，但是**它只在定义它的源文件内有效，其他源文件无法访问它**。所以，普通全局变量穿上static外衣后，它就变成了新娘，已心有所属，只能被定义它的源文件（新郎）中的变量或函数访问。</code></pre><p>普通的局部变量在栈空间上分配，这个局部变量所在的函数被多次调用时，每次调用这个局部变量在栈上的位置都不一定相同。局部变量也可以在堆上动态分配，但是记得使用完这个堆空间后要释放之。</p><p><strong>2. 静态局部变量</strong></p><p>static局部变量中文名叫<strong>静态局部变量</strong>。它与普通的局部变量比起来有如下几个区别：</p><pre><code>1）**位置**：静态局部变量被编译器放在全局存储区.data（注意：不在.bss段内，原因见3）），所以它虽然是局部的，但是在程序的整个生命周期中存在。     2）**访问权限：**静态局部变量只能被其作用域内的变量或函数访问。也就是说虽然它会在程序的整个生命周期中存在，由于它是static的，它不能被其他的函数和源文件访问。     3）**值：**静态局部变量如果没有被用户初始化，则会被编译器自动赋值为0，以后每次调用静态局部变量的时候都用上次调用后的值。这个比较好理解，每次函数调用静态局部变量的时候都修改它然后离开，下次读的时候从全局存储区读出的静态局部变量就是上次修改后的值。</code></pre><p><strong>3. 私有函数</strong></p><pre><code>当你的程序中有很多个源文件的时候，你肯定会让某个源文件只提供一些外界需要的接口，其他的函数可能是为了实现这些接口而编写，这些其他的函数你可能并不希望被外界（非本源文件）所看到，这时候就可以用static修饰这些“其他的函数”。</code></pre><p><strong>所以static函数的作用域是本源文件，把它想象为面向对象中的private函数就可以了。</strong></p><h2 id="PHP源码知识"><a href="#PHP源码知识" class="headerlink" title="PHP源码知识"></a>PHP源码知识</h2><h3 id="宏（Macro）"><a href="#宏（Macro）" class="headerlink" title="宏（Macro）"></a>宏（Macro）</h3><p>计算机科学里的宏是一种抽象（Abstraction），它根据一系列预定义的规则替换一定的文本模式。解释器或编译器在遇到宏时会自动进行这一模式替换。关于宏的详细解释，可以参考<a href="https://blog.csdn.net/hanchaoman/article/details/8809951/" target="_blank" rel="noopener">这里</a></p><p>PHP源码中大量的使用宏定义，知道以下几个宏，能够帮助我们更好的理解PHP源码。</p><p><strong>EG宏：</strong>存在于zend_globals_macros.h中，zend执行器相关的全局变量executor_globals，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Executor */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EG(v) ZEND_TSRMG(executor_globals_id, zend_executor_globals *, v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> EG(v) (executor_globals.v)</span></span><br><span class="line"><span class="keyword">extern</span> ZEND_API zend_executor_globals executor_globals;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p><strong>CG宏：</strong>存在于zend_globals_macros.h中，zend编译器相关的全局变量compiler_globals，源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CG(v) ZEND_TSRMG(compiler_globals_id, zend_compiler_globals *, v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> CG(v) (compiler_globals.v)</span></span><br><span class="line"><span class="keyword">extern</span> ZEND_API <span class="class"><span class="keyword">struct</span> _<span class="title">zend_compiler_globals</span> <span class="title">compiler_globals</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zendparse</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>PHP-named Zend macro wrappers：</strong> 位于php.h文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_FNZEND_FN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_MNZEND_MN</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_NAMED_FUNCTIONZEND_NAMED_FUNCTION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_FUNCTIONZEND_FUNCTION</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_METHOD  ZEND_METHOD</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_FEZEND_FE</span></span><br></pre></td></tr></table></figure><p><strong>Zend 宏定义：</strong>位于zend_API.h文件中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_FN(name) zif_##name</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_MN(name) zim_##name</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_NAMED_FUNCTION(name)void name(INTERNAL_FUNCTION_PARAMETERS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_FUNCTION(name)ZEND_NAMED_FUNCTION(ZEND_FN(name))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_METHOD(classname, name)ZEND_NAMED_FUNCTION(ZEND_MN(classname##_##name))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    之前看过网上零散的关于php-fpm分析的文章，要么不全，要么就是讲解php-fpm的配置文件的，还有就是讲解nginx与php-fpm之间通信配置的。关于php-fpm中的进程管理、信号管理、事件处理、时钟管理、请求处理等几乎为零。故本着学习的宗旨对fpm源码进行解读。本系列采用php-7.2.0版本中的php-fpm进行分系列讲解。本系列共分为5节，具体如下：&lt;/p&gt;
    
    </summary>
    
      <category term="php/fpm" scheme="/categories/php-fpm/"/>
    
    
      <category term="PHP" scheme="/tags/PHP/"/>
    
      <category term="源码分析" scheme="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="fpm" scheme="/tags/fpm/"/>
    
  </entry>
  
  <entry>
    <title>malloc函数详解【转载】</title>
    <link href="/c-malloc-01/"/>
    <id>/c-malloc-01/</id>
    <published>2018-07-21T16:00:00.000Z</published>
    <updated>2019-09-18T12:48:40.968Z</updated>
    
    <content type="html"><![CDATA[<p>​    很多学过C的人对malloc都不是很了解，知道使用malloc要加头文件,知道malloc是分配一块连续的内存，知道和free函数是一起用的。但是但是：一部分人还是将：malloc当作系统所提供的或者是C的关键字，事实上：malloc只是C标准库中提供的一个普通函数，而且很多很多人都对malloc的具体实现机制不是很了解。</p><a id="more"></a><h1 id="1-malloc"><a href="#1-malloc" class="headerlink" title="1 malloc"></a>1 malloc</h1><h2 id="1-1-关于malloc以及相关的几个函数"><a href="#1-1-关于malloc以及相关的几个函数" class="headerlink" title="1.1 关于malloc以及相关的几个函数"></a>1.1 关于malloc以及相关的几个函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>也可以这样认为（window下）原型：<code>extern void *malloc(unsigned int num_bytes);</code></p><p>头文件：<code>#include &lt;malloc.h&gt;</code>或者<code>#include &lt;alloc.h&gt;</code>两者的内容是完全一样的。</p><p>如果分配成功：则返回指向被分配内存空间的指针</p><p>不然，返回空指针NULL。</p><p>同时，当内存不再使用的时候，应使用free（）函数将内存块释放掉。</p><p>关于：<code>void *</code>,表示未确定类型的指针。C，C++规定，    <code>void *</code>类型可以强转为任何其他类型的的指针。</p><p><strong>malloc</strong> returns a void pointer to the allocated space, or <strong>NULL</strong> if there is insufficient memory available. To return a pointer to a type other than <strong>void</strong>, use a type cast on the return value. The storage space pointed to by the return value is guaranteed to be suitably aligned for storage of any type of object. If size is 0, <strong>malloc</strong> allocates a zero-length item in the heap and returns a valid pointer to that item. Always check the return from <strong>malloc</strong>, even if the amount of memory requested is small.</p><p>关于void *的其他说法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * p1;</span><br><span class="line"><span class="keyword">int</span> *p2;</span><br><span class="line">p1 = p2;</span><br></pre></td></tr></table></figure><p>就是说其他任意类型都可以直接赋值给它，无需进行强转，但是反过来不可以。</p><p><strong>malloc:</strong></p><p>malloc分配的内存大小至少为size参数所指定的字节数</p><p>malloc的返回值是一个指针，指向一段可用内存的起始地址</p><p>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</p><p>malloc应该尽快完成内存分配并返回（不能使用NP-hard的内存分配算法）</p><p>实现malloc时应同时实现内存大小调整和内存释放函数（realloc和free）</p><p>malloc和free函数是配对的，如果申请后不释放就是内存泄露;如果无故释放那就是什么都没有做，释放只能释放一次，如果释放两次及两次以上会出现错误（但是释放空指针例外，释放空指针其实也等于什么都没有做，所以，释放多少次都是可以的）</p><h2 id="1-2-malloc和new"><a href="#1-2-malloc和new" class="headerlink" title="1.2 malloc和new"></a>1.2 malloc和new</h2><p><strong>new：</strong>返回指定类型的指针，并且可以自动计算所需要的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">int</span>; <span class="comment">//返回类型为int *类型，分配的大小为sizeof(int)</span></span><br><span class="line">p = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>]; <span class="comment">//返回类型为int *类型，分配的大小为sizeof(int) * 100</span></span><br></pre></td></tr></table></figure><p><strong>malloc：</strong>必须由我们计算字节数，并且在返回的时候强转成实际指定类型的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure><ol><li>malloc的返回是<code>void *</code>,如果我们写成了:<code>p = malloc(sizeof(int));</code>间接的说明了（将<code>void *</code>转化给了<code>int *</code>,这不合理）</li><li>malloc的实参是sizeof(int),用于指明一个整形数据需要的大小，如果我们写成：<code>p =（int *）malloc(1),</code>那么可以看出：只是申请了一个字节的空间，如果向里面存放了一个整数的话，将会占用额外的3个字节，可能会改变原有内存空间中的数据</li><li>malloc只管分配内存，并不能对其进行初始化，所以得到的一片新内存中，其值将是随机的。一般意义上：我们习惯性的将其初始化为NULL，当然，也可以用memset函数的。</li></ol><p>简单的说：</p><p>malloc 函数其实就是在内存中：找一片指定大小的空间，然后将这个空间的首地址给一个指针变量，这里的指针变量可以是一个单独的指针，也可以是一个数组的首地址， 这要看malloc函数中参数size的具体内容。我们这里malloc分配的内存空间在逻辑上是连续的，而在物理上可以不连续。我们作为程序员，关注的 是逻辑上的连续，其它的，操作系统会帮着我们处理的。</p><h1 id="Linux内存管理"><a href="#Linux内存管理" class="headerlink" title="Linux内存管理"></a>Linux内存管理</h1><p>下面我们聊聊malloc的具体实现机制：</p><h2 id="虚拟内存地址与物理内存地址"><a href="#虚拟内存地址与物理内存地址" class="headerlink" title="虚拟内存地址与物理内存地址"></a>虚拟内存地址与物理内存地址</h2><pre><code>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时， 都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片2N字节的内存，其中N是机器位数。例如在64位CPU和64位操作系统下，每个进程的 虚拟地址空间为264Byte。</code></pre><p>　　这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p><p>　　由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫<a href="http://en.wikipedia.org/wiki/Memory_management_unit" target="_blank" rel="noopener">MMU</a>（Memory Management Unit）的硬件完成。 </p><h3 id="页与地址构成"><a href="#页与地址构成" class="headerlink" title="页与地址构成"></a>页与地址构成</h3><p>　　在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p><p>　　所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：</p><p><img src="/c-malloc-01/006tKfTcly1ftmk3vt7fij30e703c0sl.png" alt="内存地址构成"></p><p>　　上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内便宜都是用低12位表示，而剩下的高地址表示页号。</p><p>　　MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<a href="http://en.wikipedia.org/wiki/Page_table" target="_blank" rel="noopener">页表</a>来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank" rel="noopener">TLB</a>等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。</p><p><img src="/c-malloc-01/006tKfTcly1ftmk40g7otj30e70740sp.png" alt="内存地址翻译"></p><h3 id="内存页与磁盘页"><a href="#内存页与磁盘页" class="headerlink" title="内存页与磁盘页"></a>内存页与磁盘页</h3><p>　　我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异 常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现 是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。</p><p>　　最后附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程（<a href="http://en.wikipedia.org/wiki/Page_table" target="_blank" rel="noopener">图片来源页</a>）。</p><p><img src="/c-malloc-01/006tKfTcly1ftmk48xkvuj30hd0b9mx8.png" alt="较为完整的地址翻译流程"></p><h2 id="Linux进程级内存管理"><a href="#Linux进程级内存管理" class="headerlink" title="Linux进程级内存管理"></a>Linux进程级内存管理</h2><h3 id="2-2-1-内存排布"><a href="#2-2-1-内存排布" class="headerlink" title="　　2.2.1 内存排布"></a>　　2.2.1 内存排布</h3><p>　　明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p><p>　　以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p><p>　　根据<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt" target="_blank" rel="noopener">Linux内核相关文档</a>描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：</p><p><img src="/c-malloc-01/006tKfTcly1ftmk4gcr7pj30lj0ejglp.png" alt="Linux进程地址排布"></p><p>　　对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p><ul><li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li><li>Data：这里存放的是初始化过的全局变量</li><li>BSS：这里存放的是未初始化的全局变量</li><li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li><li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li><li>Stack：这是栈区域，自高地址向低地址增长</li></ul><p>　　下面我们主要关注Heap区域的操作。对整个Linux内存排布有兴趣的同学可以参考其它资料。</p><h3 id="Heap内存模型"><a href="#Heap内存模型" class="headerlink" title="Heap内存模型"></a>Heap内存模型</h3><p>　　一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p><p>　　由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：</p><p><img src="/c-malloc-01/006tKfTcly1ftmk4kperpj30kb06a74h.png" alt="Linux进程堆管理"></p><p>　　Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p><h3 id="brk与sbrk"><a href="#brk与sbrk" class="headerlink" title="brk与sbrk"></a>brk与sbrk</h3><p>　　由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">brk</span><span class="params">(<span class="keyword">void</span> *addr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sbrk</span><span class="params">(<span class="keyword">intptr_t</span> increment)</span></span>;</span><br></pre></td></tr></table></figure><p>　　brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk 在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p><p>　　一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p><p>　　另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最 后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有 一小块可用内存地址）。</p><h3 id="资源限制与rlimit"><a href="#资源限制与rlimit" class="headerlink" title="资源限制与rlimit"></a>资源限制与rlimit</h3><p>　　系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> *<span class="title">limit</span> = (<span class="title">struct</span> <span class="title">rlimit</span> *)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">rlimit</span>));</span></span><br><span class="line">    getrlimit(RLIMIT_AS, limit);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"soft limit: %ld, hard limit: %ld\n"</span>, limit-&gt;rlim_cur, limit-&gt;rlim_max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　其中rlimit是一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur; <span class="comment">/* Soft limit */</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max; <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p><h1 id="实现malloc"><a href="#实现malloc" class="headerlink" title="实现malloc"></a>实现malloc</h1><h2 id="3-1-玩具实现"><a href="#3-1-玩具实现" class="headerlink" title="　　3.1 玩具实现"></a>　　3.1 玩具实现</h2><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 一个玩具malloc */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p;</span><br><span class="line">    p = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sbrk(size) == (<span class="keyword">void</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p><h2 id="3-2-正式实现"><a href="#3-2-正式实现" class="headerlink" title="3.2 正式实现"></a>3.2 正式实现</h2><p>　　下面严肃点讨论malloc的实现方案。</p><h3 id="3-2-1-数据结构"><a href="#3-2-1-数据结构" class="headerlink" title="　　3.2.1 数据结构"></a>　　3.2.1 数据结构</h3><pre><code>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和 数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为 malloc返回的地址。可以用如下结构体定义一个block：</code></pre><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> size; <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding; <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>] <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：</p><p><img src="/c-malloc-01/006tKfTcly1ftmk5xtz1ej30kr07rmx9.png" alt="Block结构"></p><p>关于长度为1的数组注意：<a href="http://bbs.csdn.net/topics/300077699" target="_blank" rel="noopener">http://bbs.csdn.net/topics/300077699</a></p><h3 id="3-2-2-寻找合适的block"><a href="#3-2-2-寻找合适的block" class="headerlink" title="3.2.2 寻找合适的block"></a>3.2.2 寻找合适的block</h3><p>　　现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p><ul><li><strong>First fit</strong>：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块</li><li><strong>Best fit</strong>：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</li></ul><p>　　两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* First fit */</span></span><br><span class="line"><span class="function">t_block <span class="title">find_block</span><span class="params">(t_block *last, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    t_block b = first_block;</span><br><span class="line">    <span class="keyword">while</span>(b &amp;&amp; !(b-&gt;<span class="built_in">free</span> &amp;&amp; b-&gt;size &gt;= size)) &#123;</span><br><span class="line">        *last = b;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到 这返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新 block使用的，具体会在接下来的一节用到。</p><h3 id="3-2-3-开辟新的block"><a href="#3-2-3-开辟新的block" class="headerlink" title="3.2.3 开辟新的block"></a>3.2.3 开辟新的block</h3><p>　　如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 24 <span class="comment">/* 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 */</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function">t_block <span class="title">extend_heap</span><span class="params">(t_block last, <span class="keyword">size_t</span> s)</span> </span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    b = sbrk(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(sbrk(BLOCK_SIZE + s) == (<span class="keyword">void</span> *)<span class="number">-1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(last)&#123;</span><br><span class="line">        last-&gt;next = b;</span><br><span class="line">    &#125;</span><br><span class="line">    b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-4-分裂block"><a href="#3-2-4-分裂block" class="headerlink" title="　　3.2.4 分裂block"></a>　　3.2.4 分裂block</h3><p>　　First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：</p><p><img src="/c-malloc-01/006tKfTcly1ftmk8i3q88j30ku0dijrt.png" alt="分裂block"></p><p>　　实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">split_block</span><span class="params">(t_block b, <span class="keyword">size_t</span> s)</span> </span>&#123;</span><br><span class="line">    t_block <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">new</span> = b-&gt;data + s;</span><br><span class="line">    <span class="keyword">new</span>-&gt;size = b-&gt;size - s - BLOCK_SIZE ;</span><br><span class="line">    <span class="keyword">new</span>-&gt;next = b-&gt;next;</span><br><span class="line">    <span class="keyword">new</span>-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">    b-&gt;size = s;</span><br><span class="line">    b-&gt;next = <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-5-malloc的实现"><a href="#3-2-5-malloc的实现" class="headerlink" title="3.2.5 malloc的实现"></a>3.2.5 malloc的实现</h3><p>　　有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p><p>　　由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> align8(<span class="keyword">size_t</span> s) &#123;</span><br><span class="line">    <span class="keyword">if</span>(s &amp; <span class="number">0x7</span> == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((s &gt;&gt; <span class="number">3</span>) + <span class="number">1</span>) &lt;&lt; <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BLOCK_SIZE 24</span></span><br><span class="line"><span class="keyword">void</span> *first_block=<span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/* other functions... */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    t_block b, last;</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line">    <span class="comment">/* 对齐地址 */</span></span><br><span class="line">    s = align8(size);</span><br><span class="line">    <span class="keyword">if</span>(first_block) &#123;</span><br><span class="line">        <span class="comment">/* 查找合适的block */</span></span><br><span class="line">        last = first_block;</span><br><span class="line">        b = find_block(&amp;last, s);</span><br><span class="line">        <span class="keyword">if</span>(b) &#123;</span><br><span class="line">        <span class="comment">/* 如果可以，则分裂 */</span></span><br><span class="line">            <span class="keyword">if</span> ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + <span class="number">8</span>))&#123;</span><br><span class="line">                split_block(b, s);</span><br><span class="line">            &#125;</span><br><span class="line">            b-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 没有合适的block，开辟一个新的 */</span></span><br><span class="line">            b = extend_heap(last, s);</span><br><span class="line">            <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = extend_heap(<span class="literal">NULL</span>, s);</span><br><span class="line">        <span class="keyword">if</span>(!b)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        first_block = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-6-calloc的实现"><a href="#3-2-6-calloc的实现" class="headerlink" title="3.2.6 calloc的实现"></a>3.2.6 calloc的实现</h3><p>　　有了malloc，实现calloc只要两步：</p><ol><li>malloc一段内存</li><li>将数据区内容置为0</li></ol><p>　　由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> number, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> *<span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">size_t</span> s8, i;</span><br><span class="line">    <span class="keyword">new</span> = <span class="built_in">malloc</span>(number * size);</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>) &#123;</span><br><span class="line">        s8 = align8(number * size) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; s8; i++)&#123;</span><br><span class="line">    <span class="keyword">new</span>[i] = <span class="number">0</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-7-free的实现"><a href="#3-2-7-free的实现" class="headerlink" title="3.2.7 free的实现"></a>3.2.7 free的实现</h3><p>　　free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p><ol><li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li><li>如何解决碎片问题</li></ol><p>　　首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p><ul><li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li><li>这个地址确实是之前通过我们自己的malloc分配的</li></ul><p>　　第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p><p>　　首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> size; <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding; <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">/* Magic pointer，指向data */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>] <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　然后我们定义检查地址合法性的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">get_block</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *tmp;</span><br><span class="line">    tmp = p;</span><br><span class="line">    <span class="keyword">return</span> (p = tmp -= BLOCK_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">valid_addr</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(first_block) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p &gt; first_block &amp;&amp; p &lt; sbrk(<span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> p == (get_block(p))-&gt;ptr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p><p>　　一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> *<span class="title">t_block</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s_block</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> size; <span class="comment">/* 数据区大小 */</span></span><br><span class="line">    t_block prev; <span class="comment">/* 指向上个块的指针 */</span></span><br><span class="line">    t_block next; <span class="comment">/* 指向下个块的指针 */</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>; <span class="comment">/* 是否是空闲块 */</span></span><br><span class="line">    <span class="keyword">int</span> padding; <span class="comment">/* 填充4字节，保证meta块长度为8的倍数 */</span></span><br><span class="line">    <span class="keyword">void</span> *ptr; <span class="comment">/* Magic pointer，指向data */</span></span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">1</span>] <span class="comment">/* 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　合并方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">t_block <span class="title">fusion</span><span class="params">(t_block b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span>) &#123;</span><br><span class="line">        b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;</span><br><span class="line">        b-&gt;next = b-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next)&#123;</span><br><span class="line">        b-&gt;next-&gt;prev = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block 的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前 block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    t_block b;</span><br><span class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        b-&gt;<span class="built_in">free</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;<span class="built_in">free</span>)</span><br><span class="line">        b = fusion(b-&gt;prev);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;next)</span><br><span class="line">        fusion(b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;prev)</span><br><span class="line">        b-&gt;prev-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        first_block = <span class="literal">NULL</span>;</span><br><span class="line">       brk(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-8-realloc的实现"><a href="#3-2-8-realloc的实现" class="headerlink" title="　3.2.8 realloc的实现"></a>　3.2.8 realloc的实现</h3><p>　　为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copy_block</span><span class="params">(t_block src, t_block dst)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> *sdata, *ddata;</span><br><span class="line">    <span class="keyword">size_t</span> i;</span><br><span class="line">    sdata = src-&gt;ptr;</span><br><span class="line">    ddata = dst-&gt;ptr;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; (i * <span class="number">8</span>) &lt; src-&gt;size &amp;&amp; (i * <span class="number">8</span>) &lt; dst-&gt;size; i++)</span><br><span class="line">    ddata[i] = sdata[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p><ul><li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li><li>如果新的size变小了，考虑split</li><li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li></ul><p>　　下面是realloc的实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> s;</span><br><span class="line">    t_block b, <span class="keyword">new</span>;</span><br><span class="line">    <span class="keyword">void</span> *newp;</span><br><span class="line">    <span class="keyword">if</span> (!p)&#123;<span class="comment">/* 根据标准库文档，当p传入NULL时，相当于调用malloc */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(valid_addr(p)) &#123;</span><br><span class="line">        s = align8(size);</span><br><span class="line">        b = get_block(p);</span><br><span class="line">        <span class="keyword">if</span>(b-&gt;size &gt;= s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))&#123;</span><br><span class="line">                split_block(b,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* 看是否可进行合并 */</span></span><br><span class="line">            <span class="keyword">if</span>(b-&gt;next &amp;&amp; b-&gt;next-&gt;<span class="built_in">free</span> &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) &#123;</span><br><span class="line">            fusion(b);</span><br><span class="line">                <span class="keyword">if</span>(b-&gt;size - s &gt;= (BLOCK_SIZE + <span class="number">8</span>))&#123;</span><br><span class="line">                    split_block(b, s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* 新malloc */</span></span><br><span class="line">                newp = <span class="built_in">malloc</span> (s);</span><br><span class="line">                <span class="keyword">if</span> (!newp)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">new</span> = get_block(newp);</span><br><span class="line">                copy_block(b, <span class="keyword">new</span>);</span><br><span class="line">                <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">return</span>(newp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-遗留问题和优化"><a href="#3-3-遗留问题和优化" class="headerlink" title="　　3.3 遗留问题和优化"></a>　　3.3 遗留问题和优化</h2><p>　　以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p><ul><li>同时兼容32位和64位系统</li><li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li><li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li><li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li></ul><p>　　还有很多可能的优化，这里不一一赘述。下面附上一些参考文献，有兴趣的同学可以更深入研究。</p><h1 id="4-其它参考"><a href="#4-其它参考" class="headerlink" title="　　4 其它参考"></a>　　4 其它参考</h1><ol><li>这篇文章大量参考了<a href="http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf" target="_blank" rel="noopener">A malloc Tutorial</a>，其中一些图片和代码直接引用了文中的内容，这里特别指出</li><li><a href="http://csapp.cs.cmu.edu/" target="_blank" rel="noopener">Computer Systems: A Programmer’s Perspective, 2/E</a>一书有许多值得参考的地方</li><li>关于Linux的虚拟内存模型，<a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" target="_blank" rel="noopener">Anatomy of a Program in Memory</a>是很好的参考资料，另外作者还有一篇<a href="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/" target="_blank" rel="noopener">How the Kernel Manages Your Memory</a>对于Linux内核中虚拟内存管理的部分有很好的讲解</li><li>对于真实世界的malloc实现，可以参考<a href="http://repo.or.cz/w/glibc.git/blob/HEAD:/malloc/malloc.c" target="_blank" rel="noopener">glibc的实现</a></li><li>本文写作过程中大量参考了<a href="http://www.wikipedia.org/" target="_blank" rel="noopener">维基百科</a>，再次感谢这个伟大的网站，并且呼吁大家在手头允许的情况下可以适当捐助维基百科，帮助这个造福人类的系统运行下去</li></ol><p>本文转载自博客园，原文地址：<a href="https://www.cnblogs.com/Commence/p/5785912.html" target="_blank" rel="noopener">https://www.cnblogs.com/Commence/p/5785912.html</a>。看完后对内存管理知识非常清晰，非常感谢原博主的精彩分享。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    很多学过C的人对malloc都不是很了解，知道使用malloc要加头文件,知道malloc是分配一块连续的内存，知道和free函数是一起用的。但是但是：一部分人还是将：malloc当作系统所提供的或者是C的关键字，事实上：malloc只是C标准库中提供的一个普通函数，而且很多很多人都对malloc的具体实现机制不是很了解。&lt;/p&gt;
    
    </summary>
    
      <category term="c/malloc/01" scheme="/categories/c-malloc-01/"/>
    
    
      <category term="c语言" scheme="/tags/c%E8%AF%AD%E8%A8%80/"/>
    
      <category term="内存管理" scheme="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
      <category term="malloc" scheme="/tags/malloc/"/>
    
  </entry>
  
  <entry>
    <title>C语言指针详解【转载】</title>
    <link href="/c-pointer-01/"/>
    <id>/c-pointer-01/</id>
    <published>2018-07-21T16:00:00.000Z</published>
    <updated>2019-09-18T12:46:44.131Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    一直对c语言指针有种恐惧心理，觉得理解起来特别费劲，直到看到这篇文章，才突然觉得大学里c语言简直坑人。</p><a id="more"></a> <h2 id="为什么需要指针"><a href="#为什么需要指针" class="headerlink" title="为什么需要指针?"></a>为什么需要指针?</h2><p>指针解决了一些编程中基本的问题。</p><p>第一，指针的使用使得不同区域的代码可以轻易的共享内存数据。当然你也可以通过数据的复制达到相同的效果，但是这样往往效率不太好，因为诸如结构体等大型数据，占用的字节数多，复制很消耗性能。但使用指针就可以很好的避免这个问题，因为任何类型的指针占用的字节数都是一样的（根据平台不同，有4字节或者8字节或者其他可能）。</p><p>第二，指针使得一些复杂的链接性的数据结构的构建成为可能，比如链表，链式二叉树等等。</p><p>第三，有些操作必须使用指针。如操作申请的堆内存。还有：C语言中的一切函数调用中，值传递都是“按值传递”的，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成。</p><h2 id="指针是什么？"><a href="#指针是什么？" class="headerlink" title="指针是什么？"></a>指针是什么？</h2><p>我们指知道：C语言中的数组是指 一类 类型，数组具体区分为  int 类型数组，double类型数组,char数组 等等。同样指针 这个概念也泛指 一类 数据类型，int指针类型，double指针类型，char指针类型等等。</p><p>通常，我们用int类型保存一些整型的数据，如 int num = 97 ， 我们也会用char来存储字符： char ch = ‘a’。</p><p>我们也必须知道：任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p><p>因此：<strong>指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。</strong></p><p> <img src="/c-pointer-01/006tKfTcly1ftkpv5yfupj30bj03ugly.png" alt="006tKfTcly1ftkpv5yfupj30bj03ugly"></p><h2 id="为什么程序中的数据会有自己的地址？"><a href="#为什么程序中的数据会有自己的地址？" class="headerlink" title="为什么程序中的数据会有自己的地址？"></a>为什么程序中的数据会有自己的地址？</h2><p>弄清这个问题我们需要从操作系统的角度去认知内存。</p><p>电脑维修师傅眼中的内存是这样的：内存在物理上是由一组DRAM芯片组成的。</p><p>而作为一个程序员，我们不需要了解内存的物理结构，操作系统将RAM等硬件和软件结合起来，给程序员提供的一种对内存使用的抽象。,这种抽象机制使得程序使用的是虚拟存储器,而不是直接操作和使用真实存在的物理存储器。所有的虚拟地址形成的集合就是虚拟地址空间。 </p><p><img src="/c-pointer-01/006tNc79ly1ftk3cl2y2oj30j807g3zn.png" alt="img"></p><p>在程序员眼中的内存应该是下面这样的。</p><p><img src="/c-pointer-01/006tNc79ly1ftk3csnsi9j30gi037jr8.png" alt="img"></p><p>也就是说，内存是一个很大的，线性的字节数组（平坦寻址）。每一个字节都是固定的大小，由8个二进制位组成。最关键的是，每一个字节都有一个唯一的编号,编号从0开始，一直到最后一个字节。如上图中，这是一个256M的内存，他一共有256x1024x1024  = 268435456个字节，那么它的地址范围就是 0 ~268435455  。</p><p><strong>由于内存中的每一个字节都有一个唯一的编号，因此，在程序中使用的变量，常量，甚至数函数等数据，当他们被载入到内存中后，都有自己唯一的一个编号，这个编号就是这个数据的地址。指针就是这样形成的。</strong></p><p>下面用代码说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line">    <span class="keyword">int</span>  num = <span class="number">97</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ch 的地址:%p\n"</span>,&amp;ch);   <span class="comment">//ch 的地址:0028FF47</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"num的地址:%p\n"</span>,&amp;num);  <span class="comment">//num的地址:0028FF40</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针的值实质是内存单元（即字节）的编号，所以指针 单独从数值上看，也是整数，他们一般用16进制表示。指针的值（虚拟地址值）使用一个机器字的大小来存储,也就是说,对于一个机器字为w位的电脑而言,它的虚拟地址空间是0~2w － 1 ,程序最多能访问2w个字节。这就是为什么xp这种32位系统最大支持4GB内存的原因了。</p><p>我们可以大致画出变量ch和num在内存模型中的存储。（假设 char占1个字节，int占4字节）</p><h2 id="变量和内存"><a href="#变量和内存" class="headerlink" title="变量和内存"></a>变量和内存</h2><p> 为了简单起见，这里就用上面例子中的  int num = 97 这个局部变量来分析变量在内存中的存储模型。</p><p>已知：num的类型是int，占用了4个字节的内存空间，其值是97，地址是0028FF40。我们从以下几个方面去分析。</p><p><strong>1、内存的数据</strong></p><pre><code>内存的数据就是变量的值对应的二进制，一切都是二进制。97的二进制是 : 00000000 00000000 00000000 0110000 , 但使用的**小端模式**存储时，低位数据存放在低地址，所以图中画的时候是倒过来的。</code></pre><p><strong>2、内存数据的类型</strong></p><pre><code>内存的数据类型决定了这个数据占用的字节数，以及计算机将如何解释这些字节。num的类型是int，因此将被解释为 一个整数。</code></pre><p><strong>3、内存数据的名称</strong></p><pre><code>内存的名称就是变量名。实质上，内存数据都是以地址来标识的，根本没有内存的名称这个说法，这只是高级语言提供的抽象机制 ，方便我们操作内存数据。而且在C语言中，并不是所有的内存数据都有名称，例如使用malloc申请的堆内存就没有。</code></pre><p><strong>4、内存数据的地址</strong></p><pre><code>如果一个类型占用的字节数大于1，则其变量的地址就是地址值最小的那个字节的地址。因此num的地址是 0028FF40。 内存的地址用于标识这个内存块。</code></pre><p><strong>5、内存数据的生命周期</strong></p><pre><code>num是main函数中的局部变量，因此当main函数被启动时，它被分配于栈内存上，当main执行结束时，消亡。    </code></pre><p>如果一个数据一直占用着他的内存，那么我们就说他是“活着的”，如果他占用的内存被回收了，则这个数据就“消亡了”。C语言中的程序数据会按照他们定义的位置，数据的种类，修饰的关键字等因素，决定他们的生命周期特性。实质上我们程序使用的内存会被逻辑上划分为：   栈区，堆区，静态数据区，方法区。不同的区域的数据有不同的生命周期。</p><pre><code>无论以后计算机硬件如何发展，内存容量都是有限的，因此清楚理解程序中每一个程序数据的生命周期是非常重要的。我会在以后的文章中再对C语言的内存管理做出介绍，敬请期待。</code></pre><p>​     </p><h2 id="指针变量-和-指向关系"><a href="#指针变量-和-指向关系" class="headerlink" title="指针变量 和 指向关系"></a>指针变量 和 指向关系</h2><p>用来保存 指针 的变量，就是指针变量。如果指针变量p1保存了变量 num的地址，则就说：p1指向了变量num，也可以说p1指向了num所在的内存块 ，这种指向关系，在图中一般用 箭头表示。</p><p> <img src="/c-pointer-01/006tNc79ly1ftk3dmiyo0j30ln06tdg0.png" alt="img"></p><p>上图中，指针变量p1指向了num所在的内存块 ，即从地址0028FF40开始的4个byte 的内存块。</p><p><strong>定义指针变量</strong></p><p>C语言中，定义变量时，在变量名 前 写一个 * 星号，这个变量就变成了对应变量类型的指针变量。必要时要加( ) 来避免优先级的问题。</p><p>引申：C语言中，定义变量时，在定义的最前面写上typedef ，那么这个变量名就成了一种类型，即这个类型的同义词。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a ; <span class="comment">//int类型变量 a</span></span><br><span class="line"><span class="keyword">int</span> *a ; <span class="comment">//int* 变量a</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">3</span>]; <span class="comment">//arr是包含3个int元素的数组</span></span><br><span class="line"><span class="keyword">int</span> (* arr )[<span class="number">3</span>]; <span class="comment">//arr是一个指向包含3个int元素的数组的指针变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------各种类型的指针------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* p_int; <span class="comment">//指向int类型变量的指针 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>* p_double; <span class="comment">//指向idouble类型变量的指针 </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p_struct</span>;</span> <span class="comment">//结构体类型的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>(*p_func)(<span class="keyword">int</span>,<span class="keyword">int</span>); <span class="comment">//指向返回类型为int，有2个int形参的函数的指针 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>(*p_arr)[<span class="number">3</span>]; <span class="comment">//指向含有3个int元素的数组的指针 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>** p_pointer; <span class="comment">//指向 一个整形变量指针的指针</span></span><br></pre></td></tr></table></figure><p><strong>取地址</strong></p><p>既然有了指针变量，那就得让他保存其它变量的地址，使用&amp; 运算符取得一个变量的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">97</span>;</span><br><span class="line">    <span class="keyword">float</span> score = <span class="number">10.00F</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//-----------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* p_num = &amp;num;</span><br><span class="line">    <span class="keyword">float</span>* p_score = &amp;score;</span><br><span class="line">    <span class="keyword">int</span> (*p_arr)[<span class="number">3</span>] = &amp;arr;           </span><br><span class="line">    <span class="keyword">int</span> (*fp_add)(<span class="keyword">int</span> ,<span class="keyword">int</span> )  = add;  <span class="comment">//p_add是指向函数add的函数指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特殊的情况，他们并不一定需要使用&amp;取地址：</p><ul><li>数组名的值就是这个数组的第一个元素的地址。</li><li>函数名的值就是这个函数的地址。</li><li>字符串字面值常量作为右值时，就是这个字符串对应的字符数组的名称,也就是这个字符串在内存中的地址。 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a , <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="comment">//-----------------------</span></span><br><span class="line">    <span class="keyword">int</span>* p_first = arr;</span><br><span class="line">    <span class="keyword">int</span> (*fp_add)(<span class="keyword">int</span> ,<span class="keyword">int</span> )  =  add;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* msg = <span class="string">"Hello world"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解地址</strong></p><p>我们需要一个数据的指针变量干什么？当然使用通过它来操作（读/写）它指向的数据啦。对一个指针解地址，就可以取到这个内存数据，解地址 的写法，就是在指针的前面加一个*号。</p><p>解指针的实质是：从指针指向的内存块中取出这个内存数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">int</span>*p_age = &amp;age;</span><br><span class="line">    *p_age  = <span class="number">20</span>;  <span class="comment">//通过指针修改指向的内存数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age = %d\n"</span>,*p_age);   <span class="comment">//通过指针读取指向的内存数据</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age = %d\n"</span>,age);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指针之间的赋值</strong></p><p>指针赋值和int变量赋值一样，就是将地址的值拷贝给另外一个。指针之间的赋值是一种浅拷贝，是在多个编程单元之间共享内存数据的高效的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int* p1  = &amp; num;</span><br><span class="line">int* p3 = p1;</span><br><span class="line"></span><br><span class="line">//通过指针 p1 、 p3 都可以对内存数据 num 进行读写，如果2个函数分别使用了p1 和p3，那么这2个函数就共享了数据num。</span><br></pre></td></tr></table></figure><p><img src="/c-pointer-01/006tNc79ly1ftk3ebder1j30p104v0st.png" alt="img"></p><p><strong>空指针</strong></p><p>指向空，或者说不指向任何东西。在C语言中，我们让指针变量赋值为NULL表示一个空指针，而C语言中，NULL实质是 ((void*)0) ，  在C++中，NULL实质是0。</p><p>换种说法：任何程序数据都不会存储在地址为0的内存块中，它是被操作系统预留的内存块。 </p><p>下面代码摘自 stdlib.h</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#ifdef __cplusplus</span><br><span class="line">     #define NULL    0</span><br><span class="line">#else    </span><br><span class="line">     #define NULL    ((void *)0)</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><p> <strong>坏指针</strong></p><p>指针变量的值是NULL，或者未知的地址值，或者是当前应用程序不可访问的地址值，这样的指针就是坏指针，不能对他们做解指针操作，否则程序会出现运行时错误，导致程序意外终止。</p><p>任何一个指针变量在做 解地址操作前，都必须保证它指向的是有效的，可用的内存块，否则就会出错。坏指针是造成C语言Bug的最频繁的原因之一。 </p><p>下面的代码就是错误的示例。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">opp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span>*p = <span class="literal">NULL</span>;</span><br><span class="line">     *p = <span class="number">10</span>;      <span class="comment">//Oops! 不能对NULL解地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span>*p;</span><br><span class="line">     *p = <span class="number">10</span>;      <span class="comment">//Oops! 不能对一个未知的地址解地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span>*p = (<span class="keyword">int</span>*)<span class="number">1000</span>; </span><br><span class="line">     *p =<span class="number">10</span>;      <span class="comment">//Oops!   不能对一个可能不属于本程序的内存的地址的指针解地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针的2个重要属性"><a href="#指针的2个重要属性" class="headerlink" title="指针的2个重要属性"></a>指针的2个重要属性</h2><p>指针也是一种数据，指针变量也是一种变量，因此指针 这种数据也符合前面 变量和内存 主题中的特性。 这里我只想强调2个属性： 指针的类型，指针的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">97</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1  = &amp;num;</span><br><span class="line">    <span class="keyword">char</span>* p2 = (<span class="keyword">char</span>*)(&amp;num);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p1);    <span class="comment">//输出  97</span></span><br><span class="line">    <span class="built_in">putchar</span>(*p2);          <span class="comment">//输出  a</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>指针的值：很好理解，如上面的num 变量 ，其地址的值就是0028FF40 ，因此 p1的值就是0028FF40。数据的地址用于在内存中定位和标识这个数据，因为任何2个内存不重叠的不同数据的地址都是不同的。</p><p>指针的类型：指针的类型决定了这个指针指向的内存的字节数并如何解释这些字节信息。一般指针变量的类型要和它指向的数据的类型匹配。</p><p>由于num的地址是0028FF40，因此p1  和  p2的值都是0028FF40</p><p>*p1  :  将从地址0028FF40 开始解析，因为p1是int类型指针，int占4字节，因此向后连续取4个字节，并将这4个字节的二进制数据解析为一个整数 97。</p><p>*p2  :  将从地址0028FF40 开始解析，因为p2是char类型指针，char占1字节，因此向后连续取1个字节，并将这1个字节的二进制数据解析为一个字符，即’a’。 </p><p>同样的地址，因为指针的类型不同，对它指向的内存的解释就不同，得到的就是不同的数据。</p><p><strong>void*类型指针</strong> </p><p>由于void是空类型，因此void<em>类型的指针只保存了指针的值，而丢失了类型信息，我们不知道他指向的数据是什么类型的，只指定这个数据在内存中的起始地址，如果想要完整的提取指向的数据，程序员就必须对这个指针做出正确的类型转换，然后再解指针。因为，编译器不允许直接对void</em>类型的指针做解指针操作。</p><h2 id="结构体和指针"><a href="#结构体和指针" class="headerlink" title="结构体和指针"></a>结构体和指针</h2><p>结构体指针有特殊的语法：  -&gt; 符号 </p><p>如果p是一个结构体指针，则可以使用 p -&gt;【成员】 的方法访问结构体的成员</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">31</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student stu = &#123;<span class="string">"Bob"</span> , <span class="number">19</span>, <span class="number">98.0</span>&#125;;</span><br><span class="line">    Student*ps = &amp;stu;</span><br><span class="line"></span><br><span class="line">    ps-&gt;age = <span class="number">20</span>;</span><br><span class="line">    ps-&gt;score = <span class="number">99.0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name:%s age:%d\n"</span>,ps-&gt;name,ps-&gt;age);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h2><p>1、数组名作为右值的时候，就是第一个元素的地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>*p_first = arr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p_first);  <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、指向数组元素的指针 支持 递增 递减 运算。（实质上所有指针都支持递增递减 运算 ，但只有在数组中使用才是有意义的） </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>*p = arr;</span><br><span class="line">    <span class="keyword">for</span>(;p!=arr+<span class="number">3</span>;p++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,*p); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、p= p+1 意思是，让p指向原来指向的内存块的下一个相邻的相同类型的内存块。</p><pre><code>同一个数组中，元素的指针之间可以做减法运算，此时，指针之差等于下标之差。</code></pre><p>4、</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p[n]    == *(p+n)</span><br><span class="line">p[n][m] == *(*(p+n)+ m )</span><br></pre></td></tr></table></figure><p> 5、当对数组名使用sizeof时，返回的是整个数组占用的内存字节数。当把数组名赋值给一个指针后，再对指针使用sizeof运算符，返回的是指针的大小。 </p><p>这就是为什么我么将一个数组传递给一个函数时，需要另外用一个参数传递数组元素个数的原因了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>*p = arr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof(arr)=%d\n"</span>,<span class="keyword">sizeof</span>(arr));  <span class="comment">//sizeof(arr)=12</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sizeof(p)=%d\n"</span>,<span class="keyword">sizeof</span>(p));   <span class="comment">//sizeof(p)=4</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h2><p><strong>函数的参数和指针</strong></p><p>C语言中，实参传递给形参，是按值传递的，也就是说，函数中的形参是实参的拷贝份，形参和实参只是在值上面一样，而不是同一个内存数据对象。这就意味着：这种数据传递是单向的，即从调用者传递给被调函数，而被调函数无法修改传递的参数达到回传的效果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    a++;      <span class="comment">//在函数中改变的只是这个函数的局部变量a，而随着函数执行结束，a被销毁。age还是原来的age，纹丝不动。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">19</span>;</span><br><span class="line">    change(age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age = %d\n"</span>,age);   <span class="comment">// age = 19</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候我们可以使用函数的返回值来回传数据，在简单的情况下是可以的，但是如果返回值有其它用途（例如返回函数的执行状态量），或者要回传的数据不止一个，返回值就解决不了了。</p><p>传递变量的指针可以轻松解决上述问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>* pa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*pa)++;   <span class="comment">//因为传递的是age的地址，因此pa指向内存数据age。当在函数中对指针pa解地址时，</span></span><br><span class="line">               <span class="comment">//会直接去内存中找到age这个数据，然后把它增1。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age = <span class="number">19</span>;</span><br><span class="line">    change(&amp;age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"age = %d\n"</span>,age);   <span class="comment">// age = 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来一个老生常谈的，用函数交换2个变量的值的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_bad</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_ok</span><span class="params">(<span class="keyword">int</span>*pa,<span class="keyword">int</span>*pb)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">    swap_bad(a,b);       <span class="comment">//Can`t swap;</span></span><br><span class="line">    swap_ok(&amp;a,&amp;b);      <span class="comment">//OK</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误的写法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_bad</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的写法：通过指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap_ok</span><span class="params">(<span class="keyword">int</span>*pa,<span class="keyword">int</span>*pb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t=*pa;</span><br><span class="line">    *pa=*pb;</span><br><span class="line">    *pb=t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/c-pointer-01/006tNc79ly1ftk3c02qu7j30ex087jrn.png" alt="img"></p><p><img src="/c-pointer-01/006tNc79ly1ftk3br7ffij30es07qwep.png" alt="img"></p><p>有的时候，我们通过指针传递数据给函数不是为了在函数中改变他指向的对象，相反，我们防止这个目标数据被改变。传递指针只是为了避免拷贝大型数据。</p><p>考虑一个结构体类型Student。我们通过show函数输出Student变量的数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">31</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;Student;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印Student变量信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">const</span> Student * ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"name:%s , age:%d , score:%.2f\n"</span>,ps-&gt;name,ps-&gt;age,ps-&gt;score);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只是在show函数中取读Student变量的信息，而不会去修改它，为了防止意外修改，我们使用了常量指针去约束。另外我们为什么要使用指针而不是直接传递Student变量呢？</p><p>从定义的结构看出，Student变量的大小至少是39个字节，那么通过函数直接传递变量，实参赋值数据给形参需要拷贝至少39个字节的数据，极不高效。而传递变量的指针却快很多，因为在同一个平台下，无论什么类型的指针大小都是固定的：X86指针4字节，X64指针8字节，远远比一个Student结构体变量小。</p><p><strong>函数的指针</strong></p><p>每一个函数本身也是一种程序数据，一个函数包含了多条执行语句，它被编译后，实质上是多条机器指令的合集。在程序载入到内存后，函数的机器指令存放在一个特定的逻辑区域：代码区。既然是存放在内存中，那么函数也是有自己的指针的。</p><p>C语言中，函数名作为右值时，就是这个函数的指针。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>(*p)(<span class="keyword">const</span> <span class="keyword">char</span>*) = echo;   <span class="comment">//函数指针变量指向echo这个函数</span></span><br><span class="line"></span><br><span class="line">    p(<span class="string">"Hello "</span>);      <span class="comment">//通过函数的指针p调用函数，等价于echo("Hello ")</span></span><br><span class="line">    echo(<span class="string">"World\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="const-和-指针"><a href="#const-和-指针" class="headerlink" title="const 和 指针"></a>const 和 指针</h2><p>const到底修饰谁？谁才是不变的？</p><p>下面是我总结的经验，分享一下。</p><p>如果const 后面是一个类型，则跳过最近的原子类型，修饰后面的数据。（原子类型是不可再分割的类型，如int, short , char，以及typedef包装后的类型）</p><p>如果const后面就是一个数据，则直接修饰这个数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> *p1 = &amp;a;        <span class="comment">//const后面是*p1，实质是数据a，则修饰*p1，通过p1不能修改a的值</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>*p2 =  &amp;a;        <span class="comment">//const后面是int类型，则跳过int ，修饰*p2， 效果同上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* <span class="keyword">const</span> p3 = <span class="literal">NULL</span>;      <span class="comment">//const后面是数据p3。也就是指针p3本身是const .</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>* <span class="keyword">const</span> p4 = &amp;a;  <span class="comment">// 通过p4不能改变a 的值，同时p4本身也是 const</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span>* <span class="keyword">const</span> p5 = &amp;a;  <span class="comment">//效果同上</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span>* <span class="keyword">pint_t</span>;  <span class="comment">//将 int* 类型 包装为 pint_t,则pint_t 现在是一个完整的原子类型</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> a  = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">pint_t</span> p1 = &amp;a;  <span class="comment">//同样，const跳过类型pint_t，修饰p1，指针p1本身是const</span></span><br><span class="line">    <span class="keyword">pint_t</span> <span class="keyword">const</span> p2 = &amp;a;  <span class="comment">//const 直接修饰p，同上</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h2><p>如果2个程序单元（例如2个函数）是通过拷贝 他们所共享的数据的 指针来工作的，这就是浅拷贝，因为真正要访问的数据并没有被拷贝。如果被访问的数据被拷贝了，在每个单元中都有自己的一份，对目标数据的操作相互 不受影响，则叫做深拷贝。 <img src="/c-pointer-01/006tNc79ly1ftk3bhux9vj30ov07z3z1.png" alt="img"></p><h2 id="附加知识"><a href="#附加知识" class="headerlink" title="附加知识"></a>附加知识</h2><p><strong>指针和引用这个2个名词的区别</strong>。他们本质上来说是同样的东西。指针常用在C语言中，而引用，则用于诸如Java，C#等 在语言层面封装了对指针的直接操作的编程语言中。</p><p><strong>大端模式和小端模式</strong></p><p>1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。个人PC常用，Intel X86处理器是小端模式。</p><p>2) B i g-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p><p>采用大端方式 进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。有些机器同时支持大端和小端模式,通过配置来设定实际的端模式。</p><p>假如 short类型占用2个字节，且存储的地址为0x30。</p><p>short a = 1;</p><p>如下图：</p><p> <img src="/c-pointer-01/006tNc79ly1ftk3b0tdykj307x03umx0.png" alt=""></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//测试机器使用的是否为小端模式。是，则返回true，否则返回false</span></span><br><span class="line"><span class="comment">//这个方法判别的依据就是：C语言中一个对象的地址就是这个对象占用的字节中，地址值最小的那个字节的地址。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSmallIndain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> val = <span class="string">'A'</span>;</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">char</span>* p = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)&amp;val;  <span class="comment">//C/C++：对于多字节数据，取地址是取的数据对象的第一个字节的地址，也就是数据的低地址</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> *p == <span class="string">'A'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本篇文章转载自博客园，<a href="https://www.cnblogs.com/lulipro/p/7460206.html" target="_blank" rel="noopener">原文</a> 非常感谢原作者的精彩讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;​    一直对c语言指针有种恐惧心理，觉得理解起来特别费劲，直到看到这篇文章，才突然觉得大学里c语言简直坑人。&lt;/p&gt;
    
    </summary>
    
      <category term="c/pointer/01" scheme="/categories/c-pointer-01/"/>
    
    
      <category term="指针" scheme="/tags/%E6%8C%87%E9%92%88/"/>
    
      <category term="C语言" scheme="/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>PHP源码之宏【转载】</title>
    <link href="/php-source-macro-01/"/>
    <id>/php-source-macro-01/</id>
    <published>2018-07-21T09:47:26.000Z</published>
    <updated>2019-03-05T08:49:36.120Z</updated>
    
    <content type="html"><![CDATA[<p>​    作为 PHPer，我们几乎每天都在写函数，我们一定会好奇，那些 PHP 内置的函数，是长什么样子的。如果写过 PHP 扩展的话，一定知道这个宏：<code>PHP_FUNCTION</code>。在定义一个函数的时候，这样来使用这个宏。例如 <code>array_change_key_case</code>，它的定义是这样的：<code>PHP_FUNCTION(array_change_key_case)</code>。没错，就是这么简单。但是，在这个简单的背后，却没有这么简单。</p><a id="more"></a><h2 id="PHP-FUNCTION-追根溯源"><a href="#PHP-FUNCTION-追根溯源" class="headerlink" title="PHP_FUNCTION 追根溯源"></a>PHP_FUNCTION 追根溯源</h2><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>相信对这篇文章感兴趣的同学，一定多少对 C 语言以及它的宏定义有一定的了解。如果没有，也不要紧，我这里来简单解释一下，什么是宏。</p><p>C 语言中的宏，我认为，可以理解为一种简单的封装。通过宏定义，可以对开发者隐去一些细节，让开发者在使用简单的语法来完成重复的复杂的编码。当然，宏定义还有其它的用途，但是，我们在 <code>PHP_FUNCTION</code> 涉及到的就是这个作用。有下面的代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST(test) void test(int a)</span></span><br><span class="line">TEST(haha)</span><br></pre></td></tr></table></figure><p>宏，就是完全的替换，即使用后面的语句替换前面的。那么对于下面的 <code>TEST(haha)</code> 就相当于下面的样子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">haha</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br></pre></td></tr></table></figure><h3 id="PHP-FUNCTION-的定义"><a href="#PHP-FUNCTION-的定义" class="headerlink" title="PHP_FUNCTION 的定义"></a>PHP_FUNCTION 的定义</h3><p>首先，我们要定义函数，这样使用这个宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(array_change_key_case)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在 <code>php-src/main/php.h</code> 中找到了下面的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PHP_FUNCTION ZEND_FUNCTION</span></span><br></pre></td></tr></table></figure><p>也就是说，这里用 <code>ZEND_FUNCTION</code> 替换了 <code>PHP_FUNCTION</code> 这个宏。所以，我们的定义就相当于变成了这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZEND_FUNCTION(array_change_key_case)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们继续往下找，因为，这里还是宏，我们并没有看到我们希望看到的代码。我们可以在 <code>php-src/Zend/zend_API.h</code> 中找到下面的定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_FN(name) zif_##name</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_FUNCTION(name) ZEND_NAMED_FUNCTION(ZEND_FN(name))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZEND_NAMED_FUNCTION(name) void name(INTERNAL_FUNCTION_PARAMETERS)</span></span><br></pre></td></tr></table></figure><p>我们看到，在宏定义中，使用了另外的宏。不要怕，还是一个词，替换。我们按照这样的步骤来。（<code>##</code> 是一个连接符，它的作用是，是将它前面的与后面的，按照字符串的方式连接起来。</p><ol><li>替换 <code>ZEND_FUNCTION</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZEND_NAMED_FUNCTION(ZEND_FN(name))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>替换 <code>ZEND_FN</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ZEND_NAMED_FUNCTION(zif_array_change_key_case)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>替换 <code>ZEND_NAMED_FUNCTION</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zif_array_change_key_case</span><span class="params">(INTERNAL_FUNCTION_PARAMETERS)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们可以看到，这里已经基本和我们熟悉的函数定义差不多了，不过，这还没完，以为，这里还有宏，那就是 <code>INTERNAL_FUNCTION_PARAMETERS</code>。我们找到 <code>php-src/Zend/zend.h</code>，可以找到 <code>INTERNAL_FUNCTION_PARAMETERS</code>的宏定义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_FUNCTION_PARAMETERS zend_execute_data *execute_data, zval *return_value</span></span><br></pre></td></tr></table></figure><p>好了，依然按照替换的原则，我们就可以将函数定义变成这样了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zif_array_change_key_case</span><span class="params">(zend_execute_data *execute_data, zval *return_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看，整个函数的定义，已经完全没有宏了，这已经是我们在熟悉不过的 C 语言函数的定义了。这就是<br><code>PHP_FUNCTION</code> 的整个定义的过程。</p><h3 id="execute-data-和-return-value"><a href="#execute-data-和-return-value" class="headerlink" title="execute_data 和 return_value"></a>execute_data 和 return_value</h3><p><code>return_value</code>，顾名思义，就是定义的 PHP 函数的返回值。而 <code>execute_data</code>，按照我的理解，就是 Zend 内部的一个调用栈，而在执行这个函数的时候，指向的是这个函数的栈帧。具体的细节，暂时在这里先不考虑，有兴趣的同学可以来这里看一下</p><p>文章转载自segmentfault，原文地址：<a href="https://segmentfault.com/a/1190000010529733" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010529733</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    作为 PHPer，我们几乎每天都在写函数，我们一定会好奇，那些 PHP 内置的函数，是长什么样子的。如果写过 PHP 扩展的话，一定知道这个宏：&lt;code&gt;PHP_FUNCTION&lt;/code&gt;。在定义一个函数的时候，这样来使用这个宏。例如 &lt;code&gt;array_change_key_case&lt;/code&gt;，它的定义是这样的：&lt;code&gt;PHP_FUNCTION(array_change_key_case)&lt;/code&gt;。没错，就是这么简单。但是，在这个简单的背后，却没有这么简单。&lt;/p&gt;
    
    </summary>
    
      <category term="php/source/macro/01" scheme="/categories/php-source-macro-01/"/>
    
    
      <category term="PHP" scheme="/tags/PHP/"/>
    
      <category term="源码分析" scheme="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Golang是如何调度Go Routine的？【转载】</title>
    <link href="/golang-goroutine-02/"/>
    <id>/golang-goroutine-02/</id>
    <published>2017-12-21T16:00:00.000Z</published>
    <updated>2019-09-18T12:49:23.750Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要讲解go是如何调度runtine的，结合图形的方式，让人更加清晰明了，英文原文戳<a href="https://link.zhihu.com/?target=http%3A//morsmachine.dk/go-scheduler" target="_blank" rel="noopener">这里</a>。</p><a id="more"></a><h3 id="Go-runtine的调度器"><a href="#Go-runtine的调度器" class="headerlink" title="Go runtine的调度器"></a>Go runtine的调度器</h3><p> 在了解Go的运行时的scheduler之前，需要先了解为什么需要它，因为我们可能会想，OS内核不是已经有一个线程scheduler了嘛？<br> 熟悉POSIX API的人都知道，POSIX的方案在很大程度上是对Unix process进场模型的一个逻辑描述和扩展，两者有很多相似的地方。 Thread有自己的信号掩码，CPU affinity等。但是很多特征对于Go程序来说都是累赘。 尤其是context上下文切换的耗时。另一个原因是Go的垃圾回收需要所有的goroutine停止，使得内存在一个一致的状态。垃圾回收的时间点是不确定的，如果依靠OS自身的scheduler来调度，那么会有大量的线程需要停止工作。 </p><p>单独的开发一个GO得调度器，可以是其知道在什么时候内存状态是一致的，也就是说，当开始垃圾回收时，运行时只需要为当时正在CPU核上运行的那个线程等待即可，而不是等待所有的线程。</p><p>用户空间线程和内核空间线程之间的映射关系有：N:1,1:1和M:N<br> <strong>N:1是说</strong>：多个（N）用户线程始终在一个内核线程上跑，context上下文切换确实很快，但是无法真正的利用多核。<br> <strong>1:1是说</strong>：一个用户线程就只在一个内核线程上跑，这时可以利用多核，但是上下文switch很慢。<br> <strong>M:N是说</strong>：多个goroutine在多个内核线程上跑，这个看似可以集齐上面两者的优势，但是无疑增加了调度的难度。</p><p><img src="/golang-goroutine-02/006tNc79ly1ftijg0tvwaj30av02vjrp.png" alt="img"></p><p> Go的调度器内部有三个重要的结构：M，P，S<br> <strong>M:</strong>代表真正的内核OS线程，和POSIX里的thread差不多，真正干活的人<br> <strong>G:</strong>代表一个goroutine，它有自己的栈，instruction pointer和其他信息（正在等待的channel等等），用于调度。<br> <strong>P:</strong>代表调度的上下文，可以把它看做一个局部的调度器，使go代码在一个线程上跑，它是实现从N:1到N:M映射的关键。</p><p><img src="/golang-goroutine-02/006tNc79ly1ftijh62jovj30b40av75n.png" alt="img"></p><p> 图中看，有2个物理线程M，每一个M都拥有一个context（P），每一个也都有一个正在运行的goroutine。<br> P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。<br> 图中灰色的那些goroutine并没有运行，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue），<br> Go语言里，启动一个goroutine很容易：go function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个<br> goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行。</p><p>为何要维护多个上下文P？因为当一个OS线程被阻塞时，P可以转而投奔另一个OS线程！<br> 图中看到，当一个OS线程M0陷入阻塞时，P转而在OS线程M1上运行。调度器保证有足够的线程来运行所以的context P。</p><p><img src="/golang-goroutine-02/006tNc79ly1ftijgiggl3j30fa0b4wfz.png" alt="img"></p><p> 图中的M1可能是被创建，或者从线程缓存中取出。</p><p>当MO返回时，它必须尝试取得一个context P来运行goroutine，一般情况下，它会从其他的OS线程那里steal偷一个context过来，<br> 如果没有偷到的话，它就把goroutine放在一个global runqueue里，然后自己就去睡大觉了（放入线程缓存里）。Contexts们也会周期性的检查global runqueue，否则global runqueue上的goroutine永远无法执行。</p><p><img src="/golang-goroutine-02/006tNc79ly1ftijga28wzj30fa0b4q4c.png" alt="img"></p><p> 另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了一个上下文P闲着没事儿干而系统却任然忙碌。但是如果global runqueue没有任务G了，那么P就不得不从其他的上下文P那里拿一些G来执行。一般来说，如果上下文P从其他的上下文P那里要偷一个任务的话，一般就‘偷’run queue的一半，这就确保了每个OS线程都能充分的使用。 </p><p>文章转载自：<a href="https://www.zhihu.com/question/20862617/answer/27964865" target="_blank" rel="noopener">https://www.zhihu.com/question/20862617/answer/27964865</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要讲解go是如何调度runtine的，结合图形的方式，让人更加清晰明了，英文原文戳&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//morsmachine.dk/go-scheduler&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="golang/goroutine/02" scheme="/categories/golang-goroutine-02/"/>
    
    
      <category term="Golang" scheme="/tags/Golang/"/>
    
      <category term="routine" scheme="/tags/routine/"/>
    
  </entry>
  
  <entry>
    <title>Goroutine背后的系统知识【转载】</title>
    <link href="/golang-goroutine-01/"/>
    <id>/golang-goroutine-01/</id>
    <published>2017-12-11T04:30:44.000Z</published>
    <updated>2019-09-18T12:49:59.231Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://golang.org/" target="_blank" rel="noopener">Go语言</a> 从诞生到普及已经三年了，先行者大都是Web开发的背景，也有了一些普及型的书籍，可系统开发背景的人在学习这些书籍的时候，总有语焉不详的感觉，网上也有若干流传甚广的文章，可其中或多或少总有些与事实不符的技术描述。希望这篇文章能为比较缺少系统编程背景的Web开发人员介绍一下<a href="http://golang.org/doc/effective_go.html#goroutines" target="_blank" rel="noopener">goroutine</a>背后的系统知识。</p><a id="more"></a><h2 id="1、操作系统与运行库"><a href="#1、操作系统与运行库" class="headerlink" title="1、操作系统与运行库"></a>1、操作系统与运行库</h2><pre><code>对于普通的电脑用户来说，能理解应用程序是运行在操作系统之上就足够了，可对于开发者，我们还需要了解我们写的程序是如何在操作系统之上运行起来的，操作系统如何为应用程序提供服务，这样我们才能分清楚哪些服务是操作系统提供的，而哪些服务是由我们所使用的语言的运行库提供的。除了内存管理、文件管理、进程管理、外设管理等等内部模块以外，操作系统还提供了许多外部接口供应用程序使用，这些接口就是所谓的“系统调用”。从DOS时代开始，系统调用就是通过软中断的形式来提供，也就是著名的[INT 21](http://stanislavs.org/helppc/int_21.html)，程序把需要调用的功能编号放入AH寄存器，把参数放入其他指定的寄存器，然后调用INT 21，中断返回后，程序从指定的寄存器(通常是AL)里取得返回值。这样的做法一直到奔腾2也就是P6出来之前都没有变，譬如windows通过INT 2E提供系统调用，Linux则是INT 80，只不过后来的寄存器比以前大一些，而且可能再多一层跳转表查询。后来，Intel和AMD分别提供了效率更高的[SYSENTER/SYSEXIT和SYSCALL/SYSRET](http://wiki.osdev.org/Sysenter)指令来代替之前的中断方式，略过了耗时的特权级别检查以及寄存器压栈出栈的操作，直接完成从RING 3代码段到RING 0代码段的转换。系统调用都提供什么功能呢？用操作系统的名字加上对应的中断编号到谷歌上一查就可以得到完整的列表 ([Windows](http://j00ru.vexillium.org/ntapi/), [Linux](http://syscalls.kernelgrok.com/))，这个列表就是操作系统和应用程序之间沟通的协议，如果需要超出此协议的功能，我们就只能在自己的代码里去实现，譬如，对于内存管理，操作系统只提供进程级别的内存段的管理，譬如Windows的[virtualmemory](http://undocumented.ntinternals.net/UserMode/Undocumented%20Functions/Memory%20Management/Virtual%20Memory/NtAllocateVirtualMemory.html)系列，或是Linux的[brk](http://linux.die.net/man/2/brk)，操作系统不会去在乎应用程序如何为新建对象分配内存，或是如何做垃圾回收，这些都需要应用程序自己去实现。如果超出此协议的功能无法自己实现，那我们就说该操作系统不支持该功能，举个例子，Linux在2.6之前是不支持多线程的，无论如何在程序里模拟，我们都无法做出多个可以同时运行的并符合POSIX 1003.1c语义标准的调度单元。可是，我们写程序并不需要去调用中断或是SYSCALL指令，这是因为操作系统提供了一层封装，在Windows上，它是NTDLL.DLL，也就是常说的Native API，我们不但不需要去直接调用INT 2E或SYSCALL，准确的说，我们不能直接去调用INT 2E或SYSCALL，因为Windows并没有公开其调用规范，直接使用INT 2E或SYSCALL无法保证未来的兼容性。在Linux上则没有这个问题，系统调用的列表都是公开的，而且Linus非常看重兼容性，不会去做任何更改，glibc里甚至专门提供了[syscall(2)](http://linux.die.net/man/2/syscall)来方便用户直接用编号调用，不过，为了解决glibc和内核之间不同版本兼容性带来的麻烦，以及为了提高某些调用的效率(譬如__NR_ gettimeofday)，Linux上还是对部分系统调用做了一层封装，就是[VDSO](http://lwn.net/Articles/446528/) (早期叫[linux-gate.so](http://www.trilithium.com/johan/2005/08/linux-gate/))。可是，我们写程序也很少直接调用NTDLL或者VDSO，而是通过更上一层的封装，这一层处理了参数准备和返回值格式转换、以及出错处理和错误代码转换，这就是我们所使用语言的运行库，对于C语言，Linux上是glibc，Windows上是kernel32(或调用msvcrt)，对于其他语言，譬如Java，则是JRE，这些“其他语言”的运行库通常最终还是调用glibc或kernel32。“运行库”这个词其实不止包括用于和编译后的目标执行程序进行链接的库文件，也包括了脚本语言或字节码解释型语言的运行环境，譬如Python，C#的CLR，Java的JRE。对系统调用的封装只是运行库的很小一部分功能，运行库通常还提供了诸如字符串处理、数学计算、常用数据结构容器等等不需要操作系统支持的功能，同时，运行库也会对操作系统支持的功能提供更易用更高级的封装，譬如带缓存和格式的IO、线程池。</code></pre><p>所以，在我们说“某某语言新增了某某功能”的时候，通常是这么几种可能：</p><ol><li>支持新的语义或语法，从而便于我们描述和解决问题。譬如Java的泛型、Annotation、lambda表达式。</li><li>提供了新的工具或类库，减少了我们开发的代码量。譬如Python 2.7的argparse</li><li><p>对系统调用有了更良好更全面的封装，使我们可以做到以前在这个语言环境里做不到或很难做到的事情。譬如Java NIO</p><pre><code>但任何一门语言，包括其运行库和运行环境，都不可能创造出操作系统不支持的功能，Go语言也是这样，不管它的特性描述看起来多么炫丽，那必然都是其他语言也可以做到的，只不过Go提供了更方便更清晰的语义和支持，提高了开发的效率。</code></pre></li></ol><h2 id="2、并发与并行-Concurrency-and-Parallelism"><a href="#2、并发与并行-Concurrency-and-Parallelism" class="headerlink" title="2、并发与并行 (Concurrency and Parallelism)"></a>2、并发与并行 (Concurrency and Parallelism)</h2><p><strong>并发</strong>是指程序的逻辑结构。非并发的程序就是一根竹竿捅到底，只有一个逻辑控制流，也就是顺序执行的(Sequential)程序，在任何时刻，程序只会处在这个逻辑控制流的某个位置。而如果某个程序有多个独立的逻辑控制流，也就是可以同时处理(deal)多件事情，我们就说这个程序是并发的。这里的“同时”，并不一定要是真正在时钟的某一时刻(那是运行状态而不是逻辑结构)，而是指：如果把这些逻辑控制流画成时序流程图，它们在时间线上是可以重叠的。</p><p><strong>并行</strong>是指程序的运行状态。如果一个程序在某一时刻被多个CPU流水线同时进行处理，那么我们就说这个程序是以并行的形式在运行。（严格意义上讲，我们不能说某程序是“并行”的，因为“并行”不是描述程序本身，而是描述程序的运行状态，但这篇小文里就不那么咬文嚼字，以下说到“并行”的时候，就是指代“以并行的形式运行”）显然，并行一定是需要硬件支持的。</p><p>而且不难理解：</p><ol><li>并发是并行的必要条件，如果一个程序本身就不是并发的，也就是只有一个逻辑控制流，那么我们不可能让其被并行处理。</li><li>并发不是并行的充分条件，一个并发的程序，如果只被一个CPU流水线进行处理(通过分时)，那么它就不是并行的。</li><li>并发只是更符合现实问题本质的表达方式，并发的最初目的是简化代码逻辑，而不是使程序运行的更快；</li></ol><p>这几段略微抽象，我们可以用一个最简单的例子来把这些概念实例化：用C语言写一个最简单的HelloWorld，它就是非并发的，如果我们建立多个线程，每个线程里打印一个HelloWorld，那么这个程序就是并发的，如果这个程序运行在老式的单核CPU上，那么这个并发程序还不是并行的，如果我们用多核多CPU且支持多任务的操作系统来运行它，那么这个并发程序就是并行的。</p><p>还有一个略微复杂的例子，更能说明并发不一定可以并行，而且并发不是为了效率，就是Go语言例子里计算素数的<a href="http://golang.org/doc/play/sieve.go" target="_blank" rel="noopener">sieve.go</a>。我们从小到大针对每一个因子启动一个代码片段，如果当前验证的数能被当前因子除尽，则该数不是素数，如果不能，则把该数发送给下一个因子的代码片段，直到最后一个因子也无法除尽，则该数为素数，我们再启动一个它的代码片段，用于验证更大的数字。这是符合我们计算素数的逻辑的，而且每个因子的代码处理片段都是相同的，所以程序非常的简洁，但它无法被并行，因为每个片段都依赖于前一个片段的处理结果和输出。</p><p>并发可以通过以下方式做到：</p><ol><li>显式地定义并触发多个代码片段，也就是逻辑控制流，由应用程序或操作系统对它们进行调度。它们可以是独立无关的，也可以是相互依赖需要交互的，譬如上面提到的素数计算，其实它也是个经典的生产者和消费者的问题：两个逻辑控制流A和B，A产生输出，当有了输出后，B取得A的输出进行处理。线程只是实现并发的其中一个手段，除此之外，运行库或是应用程序本身也有多种手段来实现并发，这是下节的主要内容。</li><li>隐式地放置多个代码片段，在系统事件发生时触发执行相应的代码片段，也就是事件驱动的方式，譬如某个端口或管道接收到了数据(多路IO的情况下)，再譬如进程接收到了某个信号(signal)。</li></ol><p>并行可以在四个层面上做到：</p><ol><li>多台机器。自然我们就有了多个CPU流水线，譬如Hadoop集群里的MapReduce任务。</li><li>多CPU。不管是真的多颗CPU还是多核还是超线程，总之我们有了多个CPU流水线。</li><li>单CPU核里的ILP(Instruction-level parallelism)，指令级并行。通过复杂的制造工艺和对指令的解析以及分支预测和乱序执行，现在的CPU可以在单个时钟周期内执行多条指令，从而，即使是非并发的程序，也可能是以并行的形式执行。</li><li>单指令多数据(Single instruction, multiple data. SIMD)，为了多媒体数据的处理，现在的CPU的指令集支持单条指令对多条数据进行操作。</li></ol><p>其中，1牵涉到分布式处理，包括数据的分布和任务的同步等等，而且是基于网络的。3和4通常是编译器和CPU的开发人员需要考虑的。这里我们说的并行主要针对第2种：单台机器内的多核CPU并行。</p><p>关于并发与并行的问题，Go语言的作者Rob Pike专门就此写过一个幻灯片：<a href="http://talks.golang.org/2012/waza.slide" target="_blank" rel="noopener">http://talks.golang.org/2012/waza.slide</a>。在CMU那本著名的《Computer Systems: A Programmer’s Perspective》里的这张图也非常直观清晰：</p><p><img src="/golang-goroutine-01/006tNc79ly1ftigdxysyrj30e804n0sy.png" alt="Figure 12.30  Relationships between  the sets of sequential,  concurrent, and parallel  programs.  All programs  Concurrent programs  Sequential prcgrams  parallel  programs "></p><h2 id="3、线程的调度"><a href="#3、线程的调度" class="headerlink" title="3、线程的调度"></a>3、线程的调度</h2><p>上一节主要说的是并发和并行的概念，而线程是最直观的并发的实现，这一节我们主要说操作系统如何让多个线程并发的执行，当然在多CPU的时候，也就是并行的执行。我们不讨论进程，进程的意义是“隔离的执行环境”，而不是“单独的执行序列”。</p><p>我们首先需要理解IA-32 CPU的指令控制方式，这样才能理解如何在多个指令序列(也就是逻辑控制流)之间进行切换。CPU通过CS:EIP寄存器的值确定下一条指令的位置，但是CPU并不允许直接使用MOV指令来更改EIP的值，必须通过JMP系列指令、CALL/RET指令、或INT中断指令来实现代码的跳转；在指令序列间切换的时候，除了更改EIP之外，我们还要保证代码可能会使用到的各个寄存器的值，尤其是栈指针SS:ESP，以及EFLAGS标志位等，都能够恢复到目标指令序列上次执行到这个位置时候的状态。</p><p>线程是操作系统对外提供的服务，应用程序可以通过系统调用让操作系统启动线程，并负责随后的线程调度和切换。我们先考虑单颗单核CPU，操作系统内核与应用程序其实是也是在共享同一个CPU，当EIP在应用程序代码段的时候，内核并没有控制权，内核并不是一个进程或线程，内核只是以实模式运行的，代码段权限为RING 0的内存中的程序，只有当产生中断或是应用程序呼叫系统调用的时候，控制权才转移到内核，在内核里，所有代码都在同一个地址空间，为了给不同的线程提供服务，内核会为每一个线程建立一个内核堆栈，这是线程切换的关键。通常，内核会在时钟中断里或系统调用返回前(考虑到性能，通常是在不频繁发生的系统调用返回前)，对整个系统的线程进行调度，计算当前线程的剩余时间片，如果需要切换，就在“可运行”的线程队列里计算优先级，选出目标线程后，则保存当前线程的运行环境，并恢复目标线程的运行环境，其中最重要的，就是切换堆栈指针ESP，然后再把EIP指向目标线程上次被移出CPU时的指令。Linux内核在实现线程切换时，耍了个花枪，它并不是直接JMP，而是先把ESP切换为目标线程的内核栈，把目标线程的代码地址压栈，然后JMP到<a href="http://lxr.linux.no/linux+v3.8.2/arch/x86/kernel/process_32.c#L248" target="_blank" rel="noopener">__switch_to()</a>，相当于伪造了一个CALL <strong>switch_to()指令，然后，在</strong>switch_to()的最后使用RET指令返回，这样就把栈里的目标线程的代码地址放入了EIP，接下来CPU就开始执行目标线程的代码了，其实也就是上次停在<a href="http://lxr.linux.no/linux+v3.8.2/arch/x86/include/asm/switch_to.h#L31" target="_blank" rel="noopener">switch_to</a>这个宏展开的地方。</p><p>这里需要补充几点：</p><p>(1) 虽然IA-32提供了TSS (<a href="http://en.wikipedia.org/wiki/Task_state_segment" target="_blank" rel="noopener">Task State Segment</a>)，试图简化操作系统进行线程调度的流程，但由于其效率低下，而且并不是通用标准，不利于移植，所以主流操作系统都没有去利用TSS。更严格的说，其实还是用了TSS，因为只有通过TSS才能把堆栈切换到内核堆栈指针SS0:ESP0，但除此之外的TSS的功能就完全没有被使用了。</p><p>(2) 线程从用户态进入内核的时候，相关的寄存器以及用户态代码段的EIP已经保存了一次，所以，在上面所说的内核态线程切换时，需要保存和恢复的内容并不多。</p><p>(3) 以上描述的都是抢占式(preemptively)的调度方式，内核以及其中的硬件驱动也会在等待外部资源可用的时候主动调用<a href="http://lxr.linux.no/linux+v3.8.2/kernel/sched/core.c#L2845" target="_blank" rel="noopener">schedule()</a>，用户态的代码也可以通过<a href="http://linux.die.net/man/2/sched_yield" target="_blank" rel="noopener">sched_yield()</a>系统调用主动发起调度，让出CPU。</p><p>现在我们一台普通的PC或服务里通常都有多颗CPU (physical package)，每颗CPU又有多个核 (processor core)，每个核又可以支持超线程 (two logical processors for each core)，也就是逻辑处理器。每个逻辑处理器都有自己的一套完整的寄存器，其中包括了CS:EIP和SS:ESP，从而，以操作系统和应用的角度来看，每个逻辑处理器都是一个单独的流水线。在多处理器的情况下，线程切换的原理和流程其实和单处理器时是基本一致的，内核代码只有一份，当某个CPU上发生时钟中断或是系统调用时，该CPU的CS:EIP和控制权又回到了内核，内核根据调度策略的结果进行线程切换。但在这个时候，如果我们的程序用线程实现了并发，那么操作系统可以使我们的程序在多个CPU上实现并行。</p><p>这里也需要补充两点：</p><p>(1) 多核的场景里，各个核之间并不是完全对等的，譬如在同一个核上的两个超线程是共享L1/L2缓存的；在有NUMA支持的场景里，每个核访问内存不同区域的延迟是不一样的；所以，多核场景里的线程调度又引入了“调度域”(<a href="http://lwn.net/Articles/80911/" target="_blank" rel="noopener">scheduling domains</a>)的概念，但这不影响我们理解线程切换机制。</p><p>(2) 多核的场景下，中断发给哪个CPU？软中断(包括除以0，缺页异常，INT指令)自然是在触发该中断的CPU上产生，而硬中断则又分两种情况，一种是每个CPU自己产生的中断，譬如时钟，这是每个CPU处理自己的，还有一种是外部中断，譬如IO，可以通过APIC来指定其送给哪个CPU；因为调度程序只能控制当前的CPU，所以，如果IO中断没有进行均匀的分配的话，那么和IO相关的线程就只能在某些CPU上运行，导致CPU负载不均，进而影响整个系统的效率。</p><h2 id="4、并发编程框架"><a href="#4、并发编程框架" class="headerlink" title="4、并发编程框架"></a>4、并发编程框架</h2><p>以上大概介绍了一个用多线程来实现并发的程序是如何被操作系统调度以及并行执行(在有多个逻辑处理器时)，同时大家也可以看到，代码片段或者说逻辑控制流的调度和切换其实并不神秘，理论上，我们也可以不依赖操作系统和其提供的线程，在自己程序的代码段里定义多个片段，然后在我们自己程序里对其进行调度和切换。</p><p>为了描述方便，我们接下来把“代码片段”称为“任务”。</p><p>和内核的实现类似，只是我们不需要考虑中断和系统调用，那么，我们的程序本质上就是一个循环，这个循环本身就是调度程序schedule()，我们需要维护一个任务的列表，根据我们定义的策略，先进先出或是有优先级等等，每次从列表里挑选出一个任务，然后恢复各个寄存器的值，并且JMP到该任务上次被暂停的地方，所有这些需要保存的信息都可以作为该任务的属性，存放在任务列表里。</p><p>看起来很简单啊，可是我们还需要解决几个问题：</p><p>(1) 我们运行在用户态，是没有中断或系统调用这样的机制来打断代码执行的，那么，一旦我们的schedule()代码把控制权交给了任务的代码，我们下次的调度在什么时候发生？答案是，不会发生，只有靠任务主动调用schedule()，我们才有机会进行调度，所以，这里的任务不能像线程一样依赖内核调度从而毫无顾忌的执行，我们的任务里一定要显式的调用schedule()，这就是所谓的协作式(cooperative)调度。(虽然我们可以通过注册信号处理函数来模拟内核里的时钟中断并取得控制权，可问题在于，信号处理函数是由内核调用的，在其结束的时候，内核重新获得控制权，随后返回用户态并继续沿着信号发生时被中断的代码路径执行，从而我们无法在信号处理函数内进行任务切换)</p><p>(2) 堆栈。和内核调度线程的原理一样，我们也需要为每个任务单独分配堆栈，并且把其堆栈信息保存在任务属性里，在任务切换时也保存或恢复当前的SS:ESP。任务堆栈的空间可以是在当前线程的堆栈上分配，也可以是在堆上分配，但通常是在堆上分配比较好：几乎没有大小或任务总数的限制、堆栈大小可以动态扩展(gcc有split stack，但太复杂了)、便于把任务切换到其他线程。</p><p>到这里，我们大概知道了如何构造一个并发的编程框架，可如何让任务可以并行的在多个逻辑处理器上执行呢？只有内核才有调度CPU的权限，所以，我们还是必须通过系统调用创建线程，才可以实现并行。在多线程处理多任务的时候，我们还需要考虑几个问题：</p><p>(1) 如果某个任务发起了一个系统调用，譬如长时间等待IO，那当前线程就被内核放入了等待调度的队列，岂不是让其他任务都没有机会执行？</p><p>在单线程的情况下，我们只有一个解决办法，就是使用非阻塞的IO系统调用，并让出CPU，然后在schedule()里统一进行轮询，有数据时切换回该fd对应的任务；效率略低的做法是不进行统一轮询，让各个任务在轮到自己执行时再次用非阻塞方式进行IO，直到有数据可用。</p><p>如果我们采用多线程来构造我们整个的程序，那么我们可以封装系统调用的接口，当某个任务进入系统调用时，我们就把当前线程留给它(暂时)独享，并开启新的线程来处理其他任务。</p><p>(2) 任务同步。譬如我们上节提到的生产者和消费者的例子，如何让消费者在数据还没有被生产出来的时候进入等待，并且在数据可用时触发消费者继续执行呢？</p><p>在单线程的情况下，我们可以定义一个结构，其中有变量用于存放交互数据本身，以及数据的当前可用状态，以及负责读写此数据的两个任务的编号。然后我们的并发编程框架再提供read和write方法供任务调用，在read方法里，我们循环检查数据是否可用，如果数据还不可用，我们就调用schedule()让出CPU进入等待；在write方法里，我们往结构里写入数据，更改数据可用状态，然后返回；在schedule()里，我们检查数据可用状态，如果可用，则激活需要读取此数据的任务，该任务继续循环检测数据是否可用，发现可用，读取，更改状态为不可用，返回。代码的简单逻辑如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">chan</span> &#123;</span></span><br><span class="line">     <span class="keyword">bool</span> ready,</span><br><span class="line">     <span class="keyword">int</span> data</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span> <span class="params">(struct chan *c)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (c-&gt;ready) &#123;</span><br><span class="line">             c-&gt;ready = <span class="literal">false</span>;</span><br><span class="line">             <span class="keyword">return</span> c-&gt;data;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             schedule();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span> <span class="params">(struct chan *c, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (c-&gt;ready) &#123;</span><br><span class="line">             schedule(); </span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             c-&gt;data = i;</span><br><span class="line">             c-&gt;ready = <span class="literal">true</span>;</span><br><span class="line">             schedule(); <span class="comment">// optional</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，如果是多线程的话，我们需要通过线程库或系统调用提供的同步机制来保护对这个结构体内数据的访问。</p><p>以上就是最简化的一个并发框架的设计考虑，在我们实际开发工作中遇到的并发框架可能由于语言和运行库的不同而有所不同，在功能和易用性上也可能各有取舍，但底层的原理都是殊途同归。</p><p>譬如，glic里的<a href="http://linux.die.net/man/3/swapcontext" target="_blank" rel="noopener">getcontext/setcontext/swapcontext</a>系列库函数可以方便的用来保存和恢复任务执行状态；Windows提供了Fiber系列的SDK API；这二者都不是系统调用，<a href="http://linux.die.net/man/2/getcontext" target="_blank" rel="noopener">getcontext和setcontext</a>的man page虽然是在section 2，但那只是SVR4时的历史遗留问题，其实现代码是在glibc而不是kernel；<a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms682402(v=vs.85" target="_blank" rel="noopener">CreateFiber</a>.aspx)是在kernel32里提供的，NTDLL里并没有对应的NtCreateFiber。</p><p>在其他语言里，我们所谓的“任务”更多时候被称为“协程”，也就是Coroutine。譬如C++里最常用的是Boost.Coroutine；Java因为有一层字节码解释，比较麻烦，但也有支持协程的JVM补丁，或是动态修改字节码以支持协程的项目；PHP和Python的generator和yield其实已经是协程的支持，在此之上可以封装出更通用的协程接口和调度；另外还有原生支持协程的Erlang等，笔者不懂，就不说了，具体可参见Wikipedia的页面：<a href="http://en.wikipedia.org/wiki/Coroutine" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Coroutine</a></p><p>由于保存和恢复任务执行状态需要访问CPU寄存器，所以相关的运行库也都会列出所支持的CPU列表。</p><p>从操作系统层面提供协程以及其并行调度的，好像只有OS X和iOS的<a href="http://developer.apple.com/library/ios/#documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html" target="_blank" rel="noopener">Grand Central Dispatch</a>，其大部分功能也是在运行库里实现的。</p><h2 id="5、goroutine"><a href="#5、goroutine" class="headerlink" title="5、goroutine"></a>5、goroutine</h2><p>Go语言通过goroutine提供了目前为止所有(我所了解的)语言里对于并发编程的最清晰最直接的支持，Go语言的文档里对其特性也描述的非常全面甚至超过了，在这里，基于我们上面的系统知识介绍，列举一下goroutine的特性，算是小结：</p><p>(1) goroutine是Go语言运行库的功能，不是操作系统提供的功能，goroutine不是用线程实现的。具体可参见Go语言源码里的<a href="http://golang.org/src/pkg/runtime/proc.c" target="_blank" rel="noopener">pkg/runtime/proc.c</a></p><p>(2) goroutine就是一段代码，一个函数入口，以及在堆上为其分配的一个堆栈。所以它非常廉价，我们可以很轻松的创建上万个goroutine，但它们并不是被操作系统所调度执行</p><p>(3) 除了被系统调用阻塞的线程外，Go运行库最多会启动$GOMAXPROCS个线程来运行goroutine</p><p>(4) goroutine是协作式调度的，如果goroutine会执行很长时间，而且不是通过等待读取或写入channel的数据来同步的话，就需要主动调用<a href="http://golang.org/pkg/runtime/#Gosched" target="_blank" rel="noopener">Gosched()</a>来让出CPU</p><p>(5) 和所有其他并发框架里的协程一样，goroutine里所谓“无锁”的优点只在单线程下有效，如果$GOMAXPROCS &gt; 1并且协程间需要通信，Go运行库会负责加锁保护数据，这也是为什么sieve.go这样的例子在多CPU多线程时反而更慢的原因</p><p>(6) Web等服务端程序要处理的请求从本质上来讲是并行处理的问题，每个请求基本独立，互不依赖，几乎没有数据交互，这不是一个并发编程的模型，而并发编程框架只是解决了其语义表述的复杂性，并不是从根本上提高处理的效率，也许是并发连接和并发编程的英文都是concurrent吧，很容易产生“并发编程框架和coroutine可以高效处理大量并发连接”的误解。</p><p>(7) Go语言运行库封装了异步IO，所以可以写出貌似并发数很多的服务端，可即使我们通过调整$GOMAXPROCS来充分利用多核CPU并行处理，其效率也不如我们利用IO事件驱动设计的、按照事务类型划分好合适比例的线程池。在响应时间上，协作式调度是硬伤。</p><p>(8) goroutine最大的价值是其实现了并发协程和实际并行执行的线程的映射以及动态扩展，随着其运行库的不断发展和完善，其性能一定会越来越好，尤其是在CPU核数越来越多的未来，终有一天我们会为了代码的简洁和可维护性而放弃那一点点性能的差别。</p><p>文章转载自：<a href="http://www.sizeofvoid.net/goroutine-under-the-hood/" target="_blank" rel="noopener">http://www.sizeofvoid.net/goroutine-under-the-hood/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://golang.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go语言&lt;/a&gt; 从诞生到普及已经三年了，先行者大都是Web开发的背景，也有了一些普及型的书籍，可系统开发背景的人在学习这些书籍的时候，总有语焉不详的感觉，网上也有若干流传甚广的文章，可其中或多或少总有些与事实不符的技术描述。希望这篇文章能为比较缺少系统编程背景的Web开发人员介绍一下&lt;a href=&quot;http://golang.org/doc/effective_go.html#goroutines&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;goroutine&lt;/a&gt;背后的系统知识。&lt;/p&gt;
    
    </summary>
    
      <category term="golang/goroutine/01" scheme="/categories/golang-goroutine-01/"/>
    
    
      <category term="Golang" scheme="/tags/Golang/"/>
    
      <category term="routine" scheme="/tags/routine/"/>
    
  </entry>
  
  <entry>
    <title>Golang基础语法【原创】</title>
    <link href="/golang-grammar-01/"/>
    <id>/golang-grammar-01/</id>
    <published>2017-11-30T16:00:00.000Z</published>
    <updated>2018-08-25T08:07:53.987Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于GO官网上的例子写就，主要帮助自己在学习go语言的过程中记忆，更多的是自己对其中一些概念的理解。</p><a id="more"></a><h2 id="1-1-Go基础语法"><a href="#1-1-Go基础语法" class="headerlink" title="1.1 Go基础语法"></a>1.1 Go基础语法</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数声明关键字func，包括函数名、参数列表（参数名 参数类型）、函数返回值，（需要指明返回类型，可以指定返回变量名）。具体格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">funcName</span><span class="params">(a , b <span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">sum = a + b</span><br><span class="line"><span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p> <strong>int、int8、int16、int32、int64、uint、uint8、uint16、uint32、uint64、 uintptr 、byte（int8）、rune（int32）、float32、float64、complex64、complex128、 string、 bool</strong> </p><p>int，uint 和 uintptr 类型在32位的系统上一般是32位，而在64位系统上是64位。当你需要使用一个整数类型时，你应该首选 int，仅当有特别的理由才使用定长整数类型或者无符号整数类型。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量声明采用<strong>var</strong>关键字，如果声明时指定了初始值，则可以不写变量类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> = <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure><p>或短变量声明，在函数中， := 简洁赋值语句在明确类型的地方，可以用于替代 var 定义。函数外的每个语句都必须以关键字开始（ var 、 func 、等等）， := 结构不能使用在函数外。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := <span class="string">"xxx"</span></span><br></pre></td></tr></table></figure><p>var 语句定义了一个变量的列表；跟函数的参数列表一样，类型在后面。 var 语句可以定义在包或函数级别。</p><h3 id="循环for"><a href="#循环for" class="headerlink" title="循环for"></a>循环for</h3><p>Go中只有一种for循环，基本的 for 循环包含三个由分号分开的组成部分：</p><ul><li>初始化语句：在第一次循环执行前被执行</li><li>循环条件表达式：每轮迭代开始前被求值</li><li>后置语句：每轮迭代后被执行</li></ul><p>且循环条件不能有圆括号，循环体需要大括号，其语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum :=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++ &#123;</span><br><span class="line">sum++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果前置条件、后置条件和分号都去掉，这就退化为C语言中的while循环了，语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> sum &lt; <span class="number">100</span> &#123;</span><br><span class="line">    sum++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件if"><a href="#条件if" class="headerlink" title="条件if"></a>条件if</h3><p>Go中的if语句同循环一样，不需要圆括号，具体执行语句需要大括号，其语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line"><span class="comment">//todo something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if-的便捷语句"><a href="#if-的便捷语句" class="headerlink" title="if 的便捷语句"></a>if 的便捷语句</h4><p>跟 for 一样， if 语句可以在条件之前执行一个简单语句。</p><p>由这个语句定义的变量的作用域仅在 if 范围之内。包括在 if 的便捷语句定义的变量同样可以在任何对应的 else 块中使用。</p><h3 id="包的定义"><a href="#包的定义" class="headerlink" title="包的定义"></a>包的定义</h3><p>package是golang最基本的分发单位和工程管理中依赖关系的体现。每个golang源代码文件开头都拥有一个package声明，表示该golang代码所属的package。</p><p>要生成golang可执行程序，必须建立一个名为<strong>main</strong>的package，并且在该package中必须包含一个名为<strong>main()</strong>的函数。</p><p>在golang工程中，同一个路径下只能存在一个package，一个package可以拆成多个源文件组成</p><p>按照惯例，包名与导入路径的最后一个目录一致。</p><h3 id="包的导入"><a href="#包的导入" class="headerlink" title="包的导入"></a>包的导入</h3><p>包的导入使用import关键字</p><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="comment">//或者使用打包的导入语句</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="导出名"><a href="#导出名" class="headerlink" title="导出名"></a>导出名</h3><p>在 Go 中，首字母大写的名称是被导出的。</p><p>在导入包之后，你只能访问包所导出的名字，任何未导出的名字是不能被包外的代码访问的。</p><p>Foo 和 FOO 都是被导出的名称。名称 foo 是不会被导出的。</p><h3 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h3><p>变量在定义时没有明确的初始化时会赋值为零值 。</p><p>零值是：</p><ol><li>数值类型为 0 ，</li><li>布尔类型为 false ，</li><li>字符串为 “” （空字符串）。</li></ol><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>表达式 T(v) 将值 v 转换为类型 T 。</p><p>一些关于数值的转换例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i <span class="keyword">int</span> = <span class="number">42</span></span><br><span class="line"><span class="keyword">var</span> f <span class="keyword">float64</span> = <span class="keyword">float64</span>(i)</span><br><span class="line"><span class="keyword">var</span> u <span class="keyword">uint</span> = <span class="keyword">uint</span>(f)</span><br><span class="line"><span class="comment">//或者，更加简单的形式：</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">f := <span class="keyword">float64</span>(i)</span><br><span class="line">u := <span class="keyword">uint</span>(f)</span><br></pre></td></tr></table></figure><p>与 C 不同的是 Go 的在不同类型之间的赋值时需要显式转换。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量的定义与变量类似，只不过使用 const 关键字。</p><p>常量可以是字符、字符串、布尔或数字类型的值。</p><p>常量不能使用 := 语法定义。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>你可能已经知道 switch 语句会长什么样了。</p><p>除非以 fallthrough 语句结束，否则分支会自动终止。</p><p>switch 的条件从上到下的执行，当匹配成功的时候停止。</p><p>没有条件的 switch</p><p>没有条件的 switch 同 switch true 一样。</p><p>这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>defer 语句会延迟函数的执行直到上层函数返回。</p><p>延迟调用的参数会立刻生成，但是在上层函数返回前函数都不会被调用。</p><h3 id="defer栈"><a href="#defer栈" class="headerlink" title="defer栈"></a>defer栈</h3><p>延迟的函数调用被压入一个栈中。当函数返回时， 会按照后进先出的顺序调用被延迟的函数调用。</p><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>Go 具有指针。 指针保存了变量的内存地址。</p><p>类型 *T 是指向类型 T 的值的指针。其零值是 nil 。&amp; 符号会生成一个指向其作用对象的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">i := <span class="number">42</span></span><br><span class="line">p = &amp;i</span><br></pre></td></tr></table></figure><ul><li>符号表示指针指向的底层的值。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(*p) <span class="comment">// 通过指针 p 读取 i</span></span><br><span class="line">*p = <span class="number">21</span>         <span class="comment">// 通过指针 p 设置 i</span></span><br></pre></td></tr></table></figure><p>这也就是通常所说的“间接引用”或“非直接引用”。</p><p><strong>与 C 不同，Go 没有指针运算。</strong></p><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><p>一个结构体（ struct ）就是一个字段的集合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X <span class="keyword">int</span></span><br><span class="line">Y <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Vertex&#123;<span class="number">1</span>, <span class="number">2</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构体字段使用点号来访问。</p><p>结构体字段可以通过结构体指针来访问。</p><p>通过指针间接的访问是透明的。</p><h3 id="结构体文法"><a href="#结构体文法" class="headerlink" title="结构体文法"></a>结构体文法</h3><p>结构体文法表示通过结构体字段的值作为列表来新分配一个结构体。</p><p>使用 Name: 语法可以仅列出部分字段。（字段名的顺序无关。）</p><p>特殊的前缀 &amp; 返回一个指向结构体的指针。 </p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>类型 [n]T 是一个有 n 个类型为 T 的值的数组。</p><p>下面表达式定义变量 a 是一个有十个整数的数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a [<span class="number">10</span>]<span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>数组的长度是其类型的一部分，因此数组不能改变大小。 这看起来是一个制约，但是请不要担心； Go 提供了更加便利的方式来使用数组。</p><h4 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h4><p>一个 slice 会指向一个序列的值，并且包含了长度信息。</p><p>[]T 是一个元素类型为 T 的 slice。</p><p>len(s) 返回 slice s 的长度。</p><p>slice 可以包含任意的类型，包括另一个 slice。</p><h4 id="对-slice-切片"><a href="#对-slice-切片" class="headerlink" title="对 slice 切片"></a>对 slice 切片</h4><p>slice 可以重新切片，创建一个新的 slice 值指向相同的数组。</p><p>如表达式：s[lo:hi]，表示从 lo 到 hi-1 的 slice 元素，含前端，不包含后端。因此 s[lo:lo]是空的，而s[lo:lo+1]有一个元素。</p><h4 id="构造-slice"><a href="#构造-slice" class="headerlink" title="构造 slice"></a>构造 slice</h4><p>slice 由函数 <strong>make</strong> 创建。这会分配一个全是零值的数组并且返回一个 slice 指向这个数组：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>)  <span class="comment">// len(a)=5</span></span><br></pre></td></tr></table></figure><p>为了指定容量，可传递第三个参数到 make：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>, <span class="number">5</span>) <span class="comment">// len(b)=0, cap(b)=5</span></span><br><span class="line">b = b[:<span class="built_in">cap</span>(b)] <span class="comment">// len(b)=5, cap(b)=5</span></span><br><span class="line">b = b[<span class="number">1</span>:] <span class="comment">// len(b)=4, cap(b)=4</span></span><br></pre></td></tr></table></figure><h4 id="slice-的零值是-nil"><a href="#slice-的零值是-nil" class="headerlink" title="slice 的零值是 nil"></a>slice 的零值是 nil</h4><p>一个 nil 的 slice 的长度和容量是 0。</p><h4 id="向-slice-添加元素"><a href="#向-slice-添加元素" class="headerlink" title="向 slice 添加元素"></a>向 slice 添加元素</h4><p>向 slice 的末尾添加元素是一种常见的操作，因此 Go 提供了一个内建函数 <strong>append</strong> 。 内建函数的<a href="https://go-zh.org/pkg/builtin/#append" target="_blank" rel="noopener">文档</a>对 append 有详细介绍。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(s []T, vs ...T)</span> []<span class="title">T</span></span></span><br></pre></td></tr></table></figure><p>append 的第一个参数 s 是一个元素类型为 T 的 slice ，其余类型为 T 的值将会附加到该 slice 的末尾。</p><p>append 的结果是一个包含原 slice 所有元素加上新添加的元素的 slice。</p><p>如果 s 的底层数组太小，而不能容纳所有值时，会分配一个更大的数组。 返回的 slice 会指向这个新分配的数组。</p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>for 循环的 range 格式可以对 slice 或者 map 进行迭代循环。</p><p>当使用 for 循环遍历一个 slice 时，每次迭代 range 将返回两个值。 第一个是当前下标（序号），第二个是该下标所对应元素的一个拷贝。</p><p>可以通过赋值给 _ 来忽略序号和值。</p><p>如果只需要索引值，去掉 “ , value ” 的部分即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pow := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> pow &#123;</span><br><span class="line">    pow[i] = <span class="number">1</span> &lt;&lt; <span class="keyword">uint</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, value := <span class="keyword">range</span> pow &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%d\n"</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 映射键到值。</p><p>map 在使用之前必须用 <strong>make</strong> 来创建；</p><p>值为 nil 的 map 是空的，并且不能对其赋值。</p><p>map 的文法跟结构体文法相似，不过必须有键名。</p><p>若顶级类型只是一个类型名，你可以在文法的元素中省略它。</p><h4 id="修改-map"><a href="#修改-map" class="headerlink" title="修改 map"></a>修改 map</h4><p>在 map m 中插入或修改一个元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br><span class="line">m[<span class="string">"name"</span>] = <span class="string">"Golang"</span></span><br></pre></td></tr></table></figure><p>获得元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name := m[<span class="string">"name"</span>]</span><br></pre></td></tr></table></figure><p>删除元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, <span class="string">"name"</span>)</span><br></pre></td></tr></table></figure><p>通过双赋值检测某个键存在：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name, ok = m[<span class="string">"name"</span>]</span><br></pre></td></tr></table></figure><p>如果 name 在 m 中， ok 为 true。否则， ok 为 false，并且 name 是 map 的元素类型的零值。</p><p>同样的，当从 map 中读取某个不存在的键时，结果是 map 的元素类型的零值。</p><h3 id="函数值"><a href="#函数值" class="headerlink" title="函数值"></a>函数值</h3><p>函数也是值。他们可以像其他值一样传递，比如，函数值可以作为函数的参数或者返回值。</p><h3 id="函数的闭包"><a href="#函数的闭包" class="headerlink" title="函数的闭包"></a>函数的闭包</h3><p>Go 函数可以是一个闭包。闭包是一个函数值，它引用了函数体之外的变量。 这个函数可以对这个引用的变量进行访问和赋值；换句话说这个函数被“绑定”在这个变量上。</p><p>例如，函数 adder 返回一个闭包。每个返回的闭包都被绑定到其各自的 sum 变量上。</p><p>练习：斐波纳契闭包</p><p>现在来通过函数做些有趣的事情。</p><p>实现一个 fibonacci 函数，返回一个函数（一个闭包）可以返回连续的斐波纳契数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fibonacci 函数会返回一个返回 int 的函数。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    first := <span class="number">0</span></span><br><span class="line">    second := <span class="number">0</span></span><br><span class="line">    index :=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span>&#123;</span><br><span class="line">        sum := first + second</span><br><span class="line">        <span class="keyword">switch</span> index &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        first = <span class="number">0</span></span><br><span class="line">        second = <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        first = <span class="number">0</span></span><br><span class="line">        second = <span class="number">1</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        first = second</span><br><span class="line">        second = sum</span><br><span class="line">        &#125;</span><br><span class="line">        index++</span><br><span class="line">        <span class="keyword">return</span> sum</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := fibonacci()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"[%v]=&gt;%v\n"</span>,i,f())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>Go 没有类。然而，仍然可以在结构体类型上定义方法。</p><p>方法接收者 出现在 func 关键字和方法名之间的参数中。格式为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(变量 类型)</span> <span class="title">funcName</span><span class="params">(param1 type1,param2 type2)</span><span class="params">(return_param, return_type)</span></span> &#123;</span><br><span class="line"><span class="comment">//xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以对包中的 <strong>任意</strong> 类型定义任意方法，而不仅仅是针对结构体。</p><p>但是，不能对来自其他包的类型或基础类型定义方法。</p><h4 id="接收者为指针的方法"><a href="#接收者为指针的方法" class="headerlink" title="接收者为指针的方法"></a>接收者为指针的方法</h4><p>方法可以与命名类型或命名类型的指针关联。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Vertex <span class="keyword">struct</span> &#123;</span><br><span class="line">X, Y <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Scale</span><span class="params">(f <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">v.X = v.X * f</span><br><span class="line">v.Y = v.Y * f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(v *Vertex)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> math.Sqrt(v.Xv.X + v.Yv.Y)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">v := &amp;Vertex&#123;<span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">"Before scaling: %+v, Abs: %v\n"</span>, v, v.Abs())</span><br><span class="line">v.Scale(<span class="number">5</span>)</span><br><span class="line">fmt.Printf(<span class="string">"After scaling: %+v, Abs: %v\n"</span>, v, v.Abs())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚看到的两个 Abs 方法。一个是在 *Vertex 指针类型上，而另一个在 MyFloat 值类型上。 有两个原因需要使用指针接收者。首先避免在每个方法调用中拷贝值（如果值类型是大的结构体的话会更有效率）。其次，方法可以修改接收者指向的值。</p><p>尝试修改 Abs 的定义，同时 Scale 方法使用 Vertex 代替 *Vertex 作为接收者。</p><p>当 v 是 Vertex 的时候 Scale 方法没有任何作用。Scale 修改 v。当 v 是一个值（非指针），方法看到的是 Vertex 的副本，并且无法修改原始值。</p><p>Abs 的工作方式是一样的。只不过，仅仅读取 v。所以读取的是原始值（通过指针）还是那个值的副本并没有关系。</p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口类型是由一组方法定义的集合。</p><p>接口类型的值可以存放实现这些方法的任何值</p><h4 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Abser <span class="keyword">interface</span> &#123;</span><br><span class="line">Abs() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MyFloat <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f MyFloat)</span> <span class="title">Abs</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(-f)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">float64</span>(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h4><p>类型通过实现接口中的方法来实现接口。 没有显式声明的必要；所以也就没有关键字“implement“。</p><p>隐式接口解藕了实现接口的包和定义接口的包：互不依赖。</p><p>因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。</p><h4 id="Stringers"><a href="#Stringers" class="headerlink" title="Stringers"></a>Stringers</h4><p>一个普遍存在的接口是 <a href="https://go-zh.org/pkg/fmt/" target="_blank" rel="noopener">fmt</a> 包中定义的 <a href="https://go-zh.org/pkg/fmt/#Stringer" target="_blank" rel="noopener">Stringer</a>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Stringer <span class="keyword">interface</span> &#123;</span><br><span class="line">     String() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Stringer 是一个可以用字符串描述自己的类型。<code>fmt</code>包 （还有许多其他包）使用这个来进行输出。</p><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>Go 程序使用 error 值来表示错误状态。</p><p>与 fmt.Stringer 类似， error 类型是一个内建接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> error <span class="keyword">interface</span> &#123;</span><br><span class="line">     Error() <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（与 fmt.Stringer 类似，fmt 包在输出时也会试图匹配 error。）</p><p>通常函数会返回一个 error 值，调用的它的代码应当判断这个错误是否等于 nil， 来进行错误处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i, err := strconv.Atoi(<span class="string">"42"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"couldn't convert number: %v\n"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"Converted integer:"</span>, i)</span><br></pre></td></tr></table></figure><p>error 为 nil 时表示成功；非 nil 的 error 表示错误。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ErrNegativeSqrt <span class="keyword">float64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e ErrNegativeSqrt)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> e &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">"cannot Sqrt negative number:%v"</span>,<span class="keyword">float64</span>(e))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sqrt</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="params">(<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    i := ErrNegativeSqrt(x)</span><br><span class="line">    <span class="keyword">if</span> i &lt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>, i</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> math.Sqrt(x),<span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(Sqrt(<span class="number">2</span>))</span><br><span class="line">fmt.Println(Sqrt(<span class="number">-2</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Readers"><a href="#Readers" class="headerlink" title="Readers"></a>Readers</h3><p>io 包指定了 io.Reader 接口， 它表示从数据流结尾读取。</p><p>Go 标准库包含了这个接口的<a href="https://go-zh.org/search?q=Read#Global" target="_blank" rel="noopener">许多实现</a>， 包括文件、网络连接、压缩、加密等等。</p><p>io.Reader 接口有一个 Read 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(T)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure><p>Read 用数据填充指定的字节 slice，并且返回填充的字节数和错误信息。 在遇到数据流结尾时，返回 io.EOF 错误。</p><p>例子代码创建了一个 <a href="https://go-zh.org/pkg/strings/#Reader" target="_blank" rel="noopener">strings.Reader</a>。 并且以每次 8 字节的速度读取它的输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io"</span></span><br><span class="line"><span class="string">"strings"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r := strings.NewReader(<span class="string">"Hello, Reader!"</span>)</span><br><span class="line">    b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n, err := r.Read(b)</span><br><span class="line">        fmt.Printf(<span class="string">"n = %v err = %v b = %v\n"</span>, n, err, b)</span><br><span class="line">        fmt.Printf(<span class="string">"b[:n] = %q\n"</span>, b[:n])</span><br><span class="line">        <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文基于GO官网上的例子写就，主要帮助自己在学习go语言的过程中记忆，更多的是自己对其中一些概念的理解。&lt;/p&gt;
    
    </summary>
    
      <category term="golang/grammar/01" scheme="/categories/golang-grammar-01/"/>
    
    
      <category term="Golang" scheme="/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>LNMP环境解说 【原创】</title>
    <link href="/LNMP-env-01/lnmp-envrionment/"/>
    <id>/LNMP-env-01/lnmp-envrionment/</id>
    <published>2017-11-07T04:30:33.000Z</published>
    <updated>2019-09-12T04:03:47.411Z</updated>
    
    <content type="html"><![CDATA[<p>​    作为一个PHPer，没有手动搭过几次LNMP环境，都不算是一个真正的PHPer。此文主要以实际着手搭建一套lnmp环境为主线，介绍其中涉及到的技术点。包括php配置、php-fpm配置、nginx配置、mysql配置。以及这他们之间的关系。</p><a id="more"></a><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2 准备工作"></a>2 准备工作</h2><h3 id="2-1-软件下载"><a href="#2-1-软件下载" class="headerlink" title="2.1 软件下载"></a>2.1 软件下载</h3><ol><li>Linux: CentOS6.5</li><li>Nginx: 1.13.4，下载地址：<a href="http://nginx.org/download/nginx-1.13.4.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.13.4.tar.gz</a></li><li>Mysql: 5.6.37，下载地址：<a href="https://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.37.tar.gz" target="_blank" rel="noopener">https://dev.mysql.com/get/Downloads/MySQL-5.6/mysql-5.6.37.tar.gz</a></li><li>PHP: 5.5.38，下载地址：<a href="http://cn2.php.net/distributions/php-5.5.38.tar.gz" target="_blank" rel="noopener">http://cn2.php.net/distributions/php-5.5.38.tar.gz</a></li></ol><p>在/usr/local目录下创建我们的LNMP安装目录，我们这里定义为lnmp。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /usr/<span class="built_in">local</span>/lnmp/src</span><br><span class="line">wget -P /usr/<span class="built_in">local</span>/lnmp/src http://nginx.org/download/nginx-1.13.4.tar.gz</span><br><span class="line">wget -P /usr/<span class="built_in">local</span>/lnmp/src https://github.com/mysql/mysql-server/archive/mysql-5.6.37.tar.gz</span><br><span class="line">wget -P /usr/<span class="built_in">local</span>/lnmp/src http://cn2.php.net/distributions/php-5.5.38.tar.gz</span><br></pre></td></tr></table></figure><p>为了方便知道我们安装的软件版本，故目录命名均采用软件名-三位版本号的形式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/lnmp/php-5.5.38</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/lnmp/mysql-5.6.37</span><br><span class="line">mkdir /usr/<span class="built_in">local</span>/lnmp/nginx-1.10.3</span><br></pre></td></tr></table></figure><h3 id="2-2-工具安装"><a href="#2-2-工具安装" class="headerlink" title="2.2 工具安装"></a>2.2 工具安装</h3><pre><code>本实验所有的安装都是根据源码进行编译安装，编译此三软件，需要使用到的工具有:</code></pre><p><strong>cmake</strong></p><pre><code>cmake是一款开源跨平台的编译工具，其包含编译构建、测试打包等一体的工具包。其[官网](https://cmake.org/)。mysql官方文档记载说mysql 5.6版本源码编译安装需要使用cmake。其下载地址：[https://cmake.org/files/v3.9/cmake-3.9.1.tar.gz](https://cmake.org/files/v3.9/cmake-3.9.1.tar.gz) ，当然，我们也可以去github：[https://github.com/Kitware/CMake/archive/v3.9.1.tar.gz](https://github.com/Kitware/CMake/archive/v3.9.1.tar.gz) ，这里也提醒大家，所有开源软件基本都可以在github上找到，开源的世界就是这么好。感恩！</code></pre><p><strong>GCC(version &gt;= 4.2.1)</strong></p><pre><code>作为RD应该都听说过GCC（the GNU Compiler Collection），即GNU编译套件集合，是由 GNU 开发的编程语言编译器。它是以[GPL](https://baike.baidu.com/item/GPL)许可证所发行的自由软件。其包括C、C++、Objective-C、Fortran、Java、Ada和Go语言的前端，也包括了这些语言的库（如libstdc++、libgcj等等）。GCC的初衷是为GNU操作系统专门编写的一款编译器。GNU系统是彻底的自由软件。此处，“自由”的含义是它尊重用户的自由。这里不展开讲解，感兴趣的同学可以去查阅相关资料，这里给出[官网](http://gcc.gnu.org/)</code></pre><p><strong>make(version &gt;= 3.75)</strong></p><pre><code>又叫GNU Make，此软件是GNU系列的编译软件，其[官网](http://www.gnu.org/software/make/)，其[使用手册](http://www.gnu.org/software/make/manual/make.html)，既然在linux下编译软件，此软件几乎是少不了的。</code></pre><p><strong>autoconf:</strong></p><pre><code>又一款GNU下的软件，Autoconf是一个用于包，以适应多种[Unix](https://baike.baidu.com/item/Unix/219943)类系统的 [shell脚本](https://baike.baidu.com/item/shell%E8%84%9A%E6%9C%AC/572265)的工具，其[官网](http://www.gnu.org/software/autoconf/autoconf.html)，[使用手册](http://www.gnu.org/software/autoconf/manual/autoconf.html)，此软件和make基本结对出现。    </code></pre><p><strong>bison(version &gt;= 2.1)</strong></p><pre><code>GNU bison 是属于 [GNU](https://baike.baidu.com/item/GNU) 项目的一个[语法分析器](https://baike.baidu.com/item/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8)生成器。Bison 把一个关于“向前查看 从左到右 最右”(LALR) 上下文无关文法的描述转化成可以分析该文法的 C 或 [C++](https://baike.baidu.com/item/C%2B%2B) 程序。它也可以为二义文法生成 “通用的 从左到右 最右” (GLR)语法分析器。其[官网](http://www.gnu.org/software/bison/)，[使用手册](http://www.gnu.org/software/bison/manual/)</code></pre><blockquote><p>mysql源码编译安装依赖 <a href="https://dev.mysql.com/doc/refman/5.6/en/source-installation.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/source-installation.html</a></p></blockquote><h2 id="3-Nginx安装"><a href="#3-Nginx安装" class="headerlink" title="3 Nginx安装"></a>3 Nginx安装</h2><h3 id="3-1-编译安装"><a href="#3-1-编译安装" class="headerlink" title="3.1 编译安装"></a>3.1 编译安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压源码文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lnmp/src</span><br><span class="line">tar -zxf nginx-1.13.4.tar.gz</span><br><span class="line"><span class="built_in">cd</span> nginx-1.13.4</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行configure，指定安装目录为 /usr/local/lnmp/nginx-1.13.4</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/lnmp/nginx-1.13.4</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入nginx安装目录，检测是否安装成功</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lnmp/nginx-1.13.4</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行下列命令，若出现错误，跟进错误进行修正</span></span><br><span class="line">nginx -t</span><br></pre></td></tr></table></figure><h3 id="3-2-软件配置"><a href="#3-2-软件配置" class="headerlink" title="3.2 软件配置"></a>3.2 软件配置</h3><p>为了能够让我们的软件运行起来，我们最开始只做最简单的配置。</p><h4 id="3-2-1-nginx-conf"><a href="#3-2-1-nginx-conf" class="headerlink" title="3.2.1 nginx.conf"></a>3.2.1 nginx.conf</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="attribute">pid</span> logs/nginx.pid;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"><span class="comment">#日志格式</span></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line">    <span class="attribute">include</span> vhost/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-vhost"><a href="#3-2-2-vhost" class="headerlink" title="3.2.2 vhost"></a>3.2.2 vhost</h4><p>因为软件可能运行不止一个网站，故我们在nginx的conf目录下创建vhost目录，用于存放虚拟主机。同时为了把业务项目与运行环境分开，这里我们将代码目录建在/data0/www/htdocs/lnmp.com目录下，我们的网站就叫lnmp.com吧。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">9091</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line">    <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /data0/www/htdocs/lnmp.com;</span><br><span class="line">        <span class="attribute">index</span>  index.php;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>           /data0/www/htdocs/lnmp.com;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">        <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-测试"><a href="#3-3-测试" class="headerlink" title="3.3 测试"></a>3.3 测试</h3><p>检测安装是否成功，进入 /usr/local/lnmp/nginx-1.13.4/sbin目录，执行 <code>./nginx -t</code>命令，若输出如下信息，则表示安装成功。</p><blockquote><p>nginx: the configuration file /usr/local/lnmp/nginx-1.13.4/conf/nginx.conf syntax is ok<br>nginx: configuration file /usr/local/lnmp/nginx-1.13.4/conf/nginx.conf test is successful</p></blockquote><p>否则，跟进提示进行修正，如我修改完配置文件执行时，报错如下</p><blockquote><p>nginx: [emerg] unexpected “}” in /usr/local/lnmp/nginx-1.13.4/conf/nginx.conf:72<br>nginx: configuration file /usr/local/lnmp/nginx-1.13.4/conf/nginx.conf test failed</p></blockquote><p>提示很明显，因为nginx.conf文件72行遇到了不接受的”}”符号，打开文件发现其实在include vhost/*.conf后忘记添加分号，添加上分号，再次执行，提示成功。</p><h3 id="3-3-使用解读"><a href="#3-3-使用解读" class="headerlink" title="3.3 使用解读"></a>3.3 使用解读</h3><p>nginx安装完毕后，目录如下:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── client_body_temp</span><br><span class="line">├── conf //此目录为存放配置文件目录</span><br><span class="line">│   └── vhost</span><br><span class="line">├── fastcgi_temp</span><br><span class="line">├── html //存放网站代码的目录，一般情况下，我们会有自己的网站目录，这里可以存放一些统一的4xx、5xx页面。</span><br><span class="line">├── logs //默认存放nginx运行日志的地方</span><br><span class="line">├── proxy_temp</span><br><span class="line">├── sbin //此目录是存放执行命令的目录</span><br><span class="line">├── scgi_temp</span><br><span class="line">└── uwsgi_temp</span><br></pre></td></tr></table></figure><h4 id="3-3-1-sbin"><a href="#3-3-1-sbin" class="headerlink" title="3.3.1 sbin"></a>3.3.1 sbin</h4><p>这里我们先说sbin目录，其中只有一个文件nginx可执行文件，此文件用于管理nginx的启动、停止、重启。</p><p>nginx命令支持以下参数： </p><blockquote><p><strong>-v ：</strong>显示版本号并退出</p><p><strong>-V：</strong>显示版本号，同时显示编译时选项并退出</p><p><strong>-t：</strong>测试配置文件，并退出</p><p><strong>-T：</strong>测试配置文件，并将其输出，然后退出</p><p><strong>-s signal：</strong>发送信号给nginx master，用于平滑停止，退出，平滑重启，重启。signal包括（stop|quit|reload|reopen）</p><p><strong>-c：</strong>指定nginx的配置文件，默认为conf/nginx.conf</p><p><strong>-g：</strong>设置配置文件之外的全局指令，用的比较少</p></blockquote><p><strong>nginx启动</strong></p><p>使用默认的配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/lnmp/nginx-1.13.4/sbin/nginx</span><br></pre></td></tr></table></figure><p>使用指定的配置文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/lnmp/nginx-1.13.4/sbin/nginx -c /path/配置文件</span><br></pre></td></tr></table></figure><p><strong>nginx停止</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/lnmp/nginx-1.13.4/sbin/nginx -s stop</span><br></pre></td></tr></table></figure><p>对于nginx的关闭，还可以使用kill命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -QUIT 主进程pid 或 <span class="built_in">kill</span> -QUIT `cat /path/pid` 从容关闭</span><br><span class="line"><span class="built_in">kill</span> -TERM 主进程pid 或 <span class="built_in">kill</span> -TERM `cat /path/pid` 快速关闭</span><br><span class="line"><span class="built_in">kill</span> -INT 主进程pid 或 <span class="built_in">kill</span> -INT `cat /path/pid`   快速关闭</span><br><span class="line">pKill -9 主进程pid 或 pkill -9 `cat /path/pid`     强制关闭</span><br></pre></td></tr></table></figure><p>但我们推荐使用./nginx -s stop命令</p><p><strong>nginx重启</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/lnmp/nginx-1.13.4/sbin/nginx -s reload</span><br></pre></td></tr></table></figure><p>对于重启，还可以使用kill命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -USR2 `cat /path/pid`</span><br><span class="line"><span class="comment">#如本文中的示例：</span></span><br><span class="line"><span class="built_in">kill</span> -USR2 `cat /usr/<span class="built_in">local</span>/lnmp/nginx-1.13.4/logs/nginx.pid`</span><br></pre></td></tr></table></figure><h4 id="3-3-2-conf"><a href="#3-3-2-conf" class="headerlink" title="3.3.2 conf"></a>3.3.2 conf</h4><p>nginx配置文件主要为nginx.conf，这里我们就来详细解读下其中的相关配置指令及含义。</p><p>nginx的强大都是靠配置文件来实现，nginx就是一个二进制文件，nginx读入一个配置文件nginx.conf(nginx.conf可能include包含若干子配置文件)来实现各种各样的功能。我们分段来介绍nginx.conf文件。</p><h5 id="3-3-2-1-全局配置段"><a href="#3-3-2-1-全局配置段" class="headerlink" title="3.3.2.1 全局配置段"></a>3.3.2.1 全局配置段</h5><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line"><span class="attribute">pid</span>        logs/nginx.pid; </span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些是配置文件开始的默认行。通常的环境下，你不需要修改这些选项。这一部分有几个方面需要我们注意：</p><ul><li>所有以#号开的行是注释，nginx不会解析。默认的配置文件有许多说明解释的注释块</li><li>指令是以一个变量名开头(例如，worker_processes或pid),然后包含一个参数(例如，1或 logs/nginx.pid)或者多个参数(例如，”logs/error.log notice”)</li><li>所有指令以分号结尾</li><li>某些指令，像上面的<code>events</code>可以包含多个子指令作为参数。这些子指令以花括号包围。</li><li>虽然nginx不解析空白符(例如tab，空格，和换行符)，但是良好的缩进能提高你维护长期运行配置文件的效率。良好的缩进使配置文件读起来更流畅，能让你很容易明白配置的策略，即使几个月前。</li></ul><h5 id="3-3-2-2-http段"><a href="#3-3-2-2-http段" class="headerlink" title="3.3.2.2 http段"></a>3.3.2.2 http段</h5><p>官方定义如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:http &#123; ... &#125;</span><br><span class="line">Default:—</span><br><span class="line">Context:main</span><br></pre></td></tr></table></figure><p>本实践示例如下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#log 参考官方文档：http://nginx.org/en/docs/http/ngx_http_log_module.html#access_log</span></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">'<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] "<span class="variable">$request</span>" '</span></span><br><span class="line">                      <span class="string">'<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> "<span class="variable">$http_referer</span>" '</span></span><br><span class="line">                      <span class="string">'"<span class="variable">$http_user_agent</span>" "<span class="variable">$http_x_forwarded_for</span>"'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#keepalive_timeout  0;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip可以参考官方文档：http://nginx.org/en/docs/http/ngx_http_gzip_module.html</span></span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line">  <span class="attribute">gzip_min_length</span> <span class="number">1000</span>;</span><br><span class="line"><span class="attribute">gzip_proxied</span>    expired <span class="literal">no</span>-cache <span class="literal">no</span>-store private auth;</span><br><span class="line"><span class="attribute">gzip_types</span>      text/plain application/xml;</span><br><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">include</span> vhost/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“http { }”块的开头像配置文件的开头一样都是标准配置不需要修改。这里我们需要把注意力放在这些元素上:</p><ul><li>这部分内容的开始”include”语句包含/usr/local/lnmp/nginx-1.13.4/conf/mime.types文件到nginx.conf文件include语句所在位置。include对ningx.conf文件的可读性和组织性很有用。</li><li>不能过多使用include，如果太多递归地include文件会产生混乱，所以需要合理有限制地使用include来保证配置文件的清晰和可管理。</li><li>你可以去掉log_format指令前的注释并修改这几行设置的变量为你想记录的信息。</li><li>gzip指令告诉nginx使用gzip压缩的方式来降低带宽使用和加快传输速度。如果想使用gzip压缩，需要添加如下配置到配置文件的gzip位置。</li><li>include vhost/*.conf;表示包含的虚拟主机配置，这将在下一段讲解。</li></ul><h5 id="3-3-2-3-server段"><a href="#3-3-2-3-server段" class="headerlink" title="3.3.2.3 server段"></a>3.3.2.3 server段</h5><p>虚拟主机配置指令块为server，其包含与http指令块中，为了方面我们配置，我们将其独立出来，通过include指令将其包含进入http指令块中去。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:server &#123; ... &#125;</span><br><span class="line">Default:—</span><br><span class="line">Context:http</span><br></pre></td></tr></table></figure><p>本实践配置示例：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">9091</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  logs/host.access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      <span class="attribute">root</span>   /data0/www/htdocs/lnmp.com;</span><br><span class="line">      <span class="attribute">index</span>  index.php;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">      <span class="attribute">root</span>           /data0/www/htdocs/lnmp.com;</span><br><span class="line">      <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">      <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line">      <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">      <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx's one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>listen：</strong>指令告诉nginx在一个特定的hostname，ip或者tcp端口监听连接。默认，http服务运行在80端口。以下这些listen指令都是有效的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; listen     127.0.0.1:80;</span><br><span class="line">&gt; listen     localhost:80;</span><br><span class="line">&gt; listen     12.34.56.79:80;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>server_name：</strong>指令可以设置基于域名的虚拟主机，根据请求头部的内容，一个ip的服务器可以配置多个域名。以下这些配置均是可以的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; server_name lnmp.com www.lnmp.com;</span><br><span class="line">&gt; server_name *.lnmp.com;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>多个域名之间以空格分隔。nginx允许一个虚拟主机有一个或多个名字，也可以使用通配符”*”来设置虚拟主机的名字。</p></blockquote><blockquote><p><strong>access_log：</strong>用于配置虚拟主机日志，以下配置均可以。第一个使用相对路径，日志存储在/usr/local/lnmp/nginx-1.13.4/logs/lnmp.access.log中，第二个使用绝对路径，第三个表示不记录日志到文件。第一行参数有两个，第一个表示日志文件，第二个表示日志类型</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; access_log  logs/lnmp.access.log  main;</span><br><span class="line">&gt; access_log  /data0/www/logs/lnmp.access.log main;</span><br><span class="line">&gt; access_log  off;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><strong>location指令</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法:location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;</span><br><span class="line">     location @name &#123; ... &#125;</span><br><span class="line">默认: —</span><br><span class="line">运行上下文: server, location</span><br></pre></td></tr></table></figure><p><strong>语法解释：</strong></p><p><strong>~</strong>      ：波浪线表示执行一个正则匹配，区分大小写</p><p><strong>~*</strong>    ：表示执行一个正则匹配，不区分大小写</p><p><strong>^~</strong>    ：^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</p><p><strong>=</strong>      ：进行普通字符精确匹配</p><p><strong>@</strong>     ：”@” 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files</p><p><strong>location分类：</strong></p><ol><li><p>普通location（无任何前缀的、”=”、”^~ “、”@”均表示普通location）</p><p>1）严格精确匹配</p><p>2）最长前缀匹配</p></li><li>正则location（“~ ”和“~* ”前缀表示正则location）</li></ol><p>注：“^~ ”符号（^ 表示“非”，~ 表示“正则”，字符意思是：不要继续匹配正则）</p><p><strong>location匹配顺序：</strong></p><p>正则 location 匹配让步普通 location 的严格精确匹配结果；但覆盖普通 location 的最大前缀匹配结果。详细解释下就是：优先普通location匹配中的严格精确匹配，若没有命中严格精确匹配，则进行最长前缀匹配，若命中一个最长前缀匹配，则先暂时将其定为优先选择，接着进行正则匹配，若正则匹配命中，则使用正则匹配到的结果覆盖之前的最长前缀匹配结果。这里并不是所有的普通location都会进行后续的正则搜索匹配，若最长前缀匹配结果是”^~” 和 “=”，则会阻止后续的正则匹配，直接使用此结果。</p><p><strong>location物理位置：</strong></p><p>对于location之间的配置顺序，普通location 与其无关，正则location 与其有关的。</p><p><strong>location示例：</strong></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> = / &#123;</span><br><span class="line">    [ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    [ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /documents/ &#123;</span><br><span class="line">    [ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span><span class="regexp"> ^~</span> /images/ &#123;</span><br><span class="line">    [ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~* \.(gif|jpg|jpeg)$</span> &#123;</span><br><span class="line">    [ configuration E ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>“/“ 请求将会匹配配置A，因为其为普通location里的严格精确匹配，结束匹配。</li><li>“/index.html” 将会匹配配置B，此为前缀字符串匹配（普通匹配之后的正则搜索没有匹配到）</li><li>“/documents/index.html” 将会匹配配置C，先进行普通匹配，命中C，后续进行正则匹配，没有命中，故使用最长前缀匹配到的结果，所以最终匹配C。</li><li>“/images/1.gif” 将会匹配配置D，普通location最长前缀匹配成功后，不在匹配正则匹配</li><li>“/documents/1.jpg” 将会匹配配置E，最长前缀匹配到C，继续搜索正则，后正则匹配到E，则最终匹配到E</li></ol><p>更多nginx配置指令请移步官方文档：<a href="http://nginx.org/en/docs/" target="_blank" rel="noopener">http://nginx.org/en/docs/</a></p><h2 id="4-mysql安装"><a href="#4-mysql安装" class="headerlink" title="4 mysql安装"></a>4 mysql安装</h2><h3 id="4-1-编译安装"><a href="#4-1-编译安装" class="headerlink" title="4.1 编译安装"></a>4.1 编译安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加mysql用户组</span></span><br><span class="line">groupadd mysql</span><br><span class="line"><span class="comment">#添加mysql用户，且设置其组为mysql，同时设置其shell为空</span></span><br><span class="line">useradd -r -g mysql -s /bin/<span class="literal">false</span> mysql</span><br><span class="line"><span class="comment">#进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lnmp/src</span><br><span class="line"><span class="comment">#解压mysql压缩包</span></span><br><span class="line">tar -zxf mysql-5.6.37.tar.gz</span><br><span class="line"><span class="built_in">cd</span> mysql-5.6.37</span><br><span class="line">mkdir bld</span><br><span class="line"><span class="built_in">cd</span> bld</span><br><span class="line"><span class="comment">#编译的参数可以参考:http://dev.mysql.com/doc/refman/5.5/en/source-configuration-option s.html</span></span><br><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/usr/<span class="built_in">local</span>/lnmp/mysql-5.6.37 ..</span><br><span class="line">make &amp;&amp; make install</span><br><span class="line">chown -R mysql .</span><br><span class="line">chgrp -R mysql .</span><br><span class="line"><span class="comment">#初始化数据库，此操作会在安装目录下同时生成my.cnf文件</span></span><br><span class="line">scripts/mysql_install_db --user=mysql</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动mysql</span></span><br><span class="line">/usr/<span class="built_in">local</span>/lnmp/mysql-5.6.37/bin/mysqld --user=mysql --explicit_defaults_for_timestamp</span><br><span class="line"><span class="comment">#停掉mysql</span></span><br><span class="line">/usr/<span class="built_in">local</span>/lnmp/mysql-5.6.37/bin/mysqladmin shutdown</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#在测试库创建测试用户表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (<span class="string">`id`</span> <span class="built_in">bigint</span> <span class="keyword">unsigned</span> auto_increment <span class="keyword">comment</span> <span class="string">'主键'</span>,<span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">30</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="string">''</span> <span class="keyword">comment</span> <span class="string">'姓名'</span>,<span class="string">`age`</span> tinyint <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="number">0</span> <span class="keyword">comment</span> <span class="string">'年龄'</span>, primary <span class="keyword">key</span> <span class="keyword">id</span>(<span class="string">`id`</span>) ) <span class="keyword">ENGINE</span> = <span class="keyword">innodb</span> AUTO_INCREMENT = <span class="number">1</span> <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> = utf8;</span><br><span class="line"></span><br><span class="line">#插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span>(<span class="string">`id`</span>,<span class="string">`name`</span>,<span class="string">`age`</span>) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">'安琪拉'</span>,<span class="number">34</span>),(<span class="number">1</span>,<span class="string">'王昭君'</span>,<span class="number">34</span>);</span><br></pre></td></tr></table></figure><h3 id="4-2-配置"><a href="#4-2-配置" class="headerlink" title="4.2 配置"></a>4.2 配置</h3><p><a href="http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html" target="_blank" rel="noopener">官方文档</a>，mysql启动时，需要加载my.cnf配置文件，加载查找路径为：/etc/my.cnf &gt; $basedir/my.cnf 本实践中查找路径为/usr/local/lnmp/mysql-5.6.37/my.cnf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[client]</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">socket</span> = /tmp/mysql.sock</span><br><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">port</span> = <span class="number">3306</span></span><br><span class="line"><span class="attr">socket</span> = /tmp/mysql.sock</span><br><span class="line"><span class="attr">basedir</span> = /usr/local/lnmp/mysql-<span class="number">5.6</span>.<span class="number">37</span></span><br><span class="line"><span class="attr">datadir</span> = /usr/local/lnmp/mysql-<span class="number">5.6</span>.<span class="number">37</span>/data</span><br><span class="line"><span class="attr">pid-file</span> = /usr/local/lnmp/mysql-<span class="number">5.6</span>.<span class="number">37</span>/data/mysql.pid</span><br><span class="line"><span class="attr">user</span> = mysql</span><br><span class="line"><span class="attr">bind-address</span> = <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="comment">#表示是本机的序号为1,一般来讲就是master的意思</span></span><br><span class="line"><span class="attr">server-id</span> = <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#skip-name-resolve</span></span><br><span class="line"><span class="comment"># 禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，</span></span><br><span class="line"><span class="comment"># 则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求</span></span><br><span class="line"><span class="comment">#skip-networking</span></span><br><span class="line"><span class="attr">back_log</span> = <span class="number">600</span></span><br><span class="line"><span class="comment"># MySQL能有的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，这就起作用，</span></span><br><span class="line"><span class="comment"># 然后主线程花些时间(尽管很短)检查连接并且启动一个新线程。back_log值指出在MySQL暂时停止回答新请求之前的短时间内多少个请求可以被存在堆栈中。</span></span><br><span class="line"><span class="comment"># 如果期望在一个短时间内有很多连接，你需要增加它。也就是说，如果MySQL的连接数据达到max_connections时，新来的请求将会被存在堆栈中，</span></span><br><span class="line"><span class="comment"># 以等待某一连接释放资源，该堆栈的数量即back_log，如果等待连接的数量超过back_log，将不被授予连接资源。</span></span><br><span class="line"><span class="comment"># 另外，这值（back_log）限于您的操作系统对到来的TCP/IP连接的侦听队列的大小。</span></span><br><span class="line"><span class="comment"># 你的操作系统在这个队列大小上有它自己的限制（可以检查你的OS文档找出这个变量的最大值），试图设定back_log高于你的操作系统的限制将是无效的。</span></span><br><span class="line"><span class="attr">max_connections</span> = <span class="number">1000</span></span><br><span class="line"><span class="comment"># MySQL的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量，当然这建立在机器能支撑的情况下，因为如果连接数越多，介于MySQL会为每个连接提供连接缓冲区，就会开销越多的内存，所以要适当调整该值，不能盲目提高设值。可以过'conn%'通配符查看当前状态的连接数量，以定夺该值的大小。</span></span><br><span class="line"><span class="attr">max_connect_errors</span> = <span class="number">6000</span></span><br><span class="line"><span class="comment"># 对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。</span></span><br><span class="line"><span class="attr">open_files_limit</span> = <span class="number">65535</span></span><br><span class="line"><span class="comment"># MySQL打开的文件描述符限制，默认最小1024;当open_files_limit没有被配置的时候，比较max_connections*5和ulimit -n的值，哪个大用哪个，</span></span><br><span class="line"><span class="comment"># 当open_file_limit被配置的时候，比较open_files_limit和max_connections*5的值，哪个大用哪个。</span></span><br><span class="line"><span class="attr">table_open_cache</span> = <span class="number">128</span></span><br><span class="line"><span class="comment"># MySQL每打开一个表，都会读入一些数据到table_open_cache缓存中，当MySQL在这个缓存中找不到相应信息时，才会去磁盘上读取。默认值64</span></span><br><span class="line"><span class="comment"># 假定系统有200个并发连接，则需将此参数设置为200*N(N为每个连接所需的文件描述符数目)；</span></span><br><span class="line"><span class="comment"># 当把table_open_cache设置为很大时，如果系统处理不了那么多文件描述符，那么就会出现客户端失效，连接不上</span></span><br><span class="line"><span class="attr">max_allowed_packet</span> = <span class="number">4</span>M</span><br><span class="line"><span class="comment"># 接受的数据包大小；增加该变量的值十分安全，这是因为仅当需要时才会分配额外内存。例如，仅当你发出长查询或MySQLd必须返回大的结果行时MySQLd才会分配更多内存。</span></span><br><span class="line"><span class="comment"># 该变量之所以取较小默认值是一种预防措施，以捕获客户端和服务器之间的错误信息包，并确保不会因偶然使用大的信息包而导致内存溢出。</span></span><br><span class="line"><span class="attr">binlog_cache_size</span> = <span class="number">1</span>M</span><br><span class="line"><span class="comment"># 一个事务，在没有提交的时候，产生的日志，记录到Cache中；等到事务提交需要提交的时候，则把日志持久化到磁盘。默认binlog_cache_size大小32K</span></span><br><span class="line"><span class="attr">max_heap_table_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="comment"># 定义了用户可以创建的内存表(memory table)的大小。这个值用来计算内存表的最大行数值。这个变量支持动态改变</span></span><br><span class="line"><span class="attr">tmp_table_size</span> = <span class="number">16</span>M</span><br><span class="line"><span class="comment"># MySQL的heap（堆积）表缓冲大小。所有联合在一个DML指令内完成，并且大多数联合甚至可以不用临时表即可以完成。</span></span><br><span class="line"><span class="comment"># 大多数临时表是基于内存的(HEAP)表。具有大的记录长度的临时表 (所有列的长度的和)或包含BLOB列的表存储在硬盘上。</span></span><br><span class="line"><span class="comment"># 如果某个内部heap（堆积）表大小超过tmp_table_size，MySQL可以根据需要自动将内存中的heap表改为基于硬盘的MyISAM表。还可以通过设置tmp_table_size选项来增加临时表的大小。也就是说，如果调高该值，MySQL同时将增加heap表的大小，可达到提高联接查询速度的效果</span></span><br><span class="line"><span class="attr">read_buffer_size</span> = <span class="number">2</span>M</span><br><span class="line"><span class="comment"># MySQL读入缓冲区大小。对表进行顺序扫描的请求将分配一个读入缓冲区，MySQL会为它分配一段内存缓冲区。read_buffer_size变量控制这一缓冲区的大小。</span></span><br><span class="line"><span class="comment"># 如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能</span></span><br><span class="line"><span class="attr">read_rnd_buffer_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="comment"># MySQL的随机读缓冲区大小。当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，</span></span><br><span class="line"><span class="comment"># MySQL会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大</span></span><br><span class="line"><span class="attr">sort_buffer_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="comment"># MySQL执行排序使用的缓冲大小。如果想要增加ORDER BY的速度，首先看是否可以让MySQL使用索引而不是额外的排序阶段。</span></span><br><span class="line"><span class="comment"># 如果不能，可以尝试增加sort_buffer_size变量的大小</span></span><br><span class="line"><span class="attr">join_buffer_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="comment"># 联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享</span></span><br><span class="line"><span class="attr">thread_cache_size</span> = <span class="number">8</span></span><br><span class="line"><span class="comment"># 这个值（默认8）表示可以重新利用保存在缓存中线程的数量，当断开连接时如果缓存中还有空间，那么客户端的线程将被放到缓存中，</span></span><br><span class="line"><span class="comment"># 如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，</span></span><br><span class="line"><span class="comment"># 增加这个值可以改善系统性能.通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。(–&gt;表示要调整的值)</span></span><br><span class="line"><span class="comment"># 根据物理内存设置规则如下：</span></span><br><span class="line"><span class="comment"># 1G  —&gt; 8</span></span><br><span class="line"><span class="comment"># 2G  —&gt; 16</span></span><br><span class="line"><span class="comment"># 3G  —&gt; 32</span></span><br><span class="line"><span class="comment"># 大于3G  —&gt; 64</span></span><br><span class="line"><span class="attr">query_cache_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="comment">#MySQL的查询缓冲大小（从4.0.1开始，MySQL提供了查询缓冲机制）使用查询缓冲，MySQL将SELECT语句和查询结果存放在缓冲区中，</span></span><br><span class="line"><span class="comment"># 今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。根据MySQL用户手册，使用查询缓冲最多可以达到238%的效率。</span></span><br><span class="line"><span class="comment"># 通过检查状态值'Qcache_%'，可以知道query_cache_size设置是否合理：如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，</span></span><br><span class="line"><span class="comment"># 如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，</span></span><br><span class="line"><span class="comment"># 这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲</span></span><br><span class="line"><span class="attr">query_cache_limit</span> = <span class="number">2</span>M</span><br><span class="line"><span class="comment">#指定单个查询能够使用的缓冲区大小，默认1M</span></span><br><span class="line"><span class="attr">key_buffer_size</span> = <span class="number">4</span>M</span><br><span class="line"><span class="comment">#指定用于索引的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，</span></span><br><span class="line"><span class="comment"># 系统将开始换页并且真的变慢了。对于内存在4GB左右的服务器该参数可设置为384M或512M。通过检查状态值Key_read_requests和Key_reads，</span></span><br><span class="line"><span class="comment"># 可以知道key_buffer_size设置是否合理。比例key_reads/key_read_requests应该尽可能的低，</span></span><br><span class="line"><span class="comment"># 至少是1:100，1:1000更好(上述状态值可以使用SHOW STATUS LIKE 'key_read%'获得)。注意：该参数值设置的过大反而会是服务器整体效率降低</span></span><br><span class="line"><span class="attr">ft_min_word_len</span> = <span class="number">4</span></span><br><span class="line"><span class="comment"># 分词词汇最小长度，默认4</span></span><br><span class="line"><span class="attr">transaction_isolation</span> = REPEATABLE-READ</span><br><span class="line"><span class="comment"># MySQL支持4种事务隔离级别，他们分别是：</span></span><br><span class="line"><span class="comment"># READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE.</span></span><br><span class="line"><span class="comment"># 如没有指定，MySQL默认采用的是REPEATABLE-READ，ORACLE默认的是READ-COMMITTED</span></span><br><span class="line"><span class="attr">log_bin</span> = mysql-bin</span><br><span class="line"><span class="attr">binlog_format</span> = mixed</span><br><span class="line"><span class="comment">#超过30天的binlog删除</span></span><br><span class="line"><span class="attr">expire_logs_days</span> = <span class="number">30</span> </span><br><span class="line"><span class="comment">#错误日志路径</span></span><br><span class="line"><span class="attr">log_error</span> = /usr/local/lnmp/mysql-<span class="number">5.6</span>.<span class="number">37</span>/data/mysql.err</span><br><span class="line"><span class="attr">slow_query_log</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">#慢查询时间 超过1秒则为慢查询</span></span><br><span class="line"><span class="attr">long_query_time</span> = <span class="number">1</span> </span><br><span class="line"><span class="attr">slow_query_log_file</span> = /usr/local/lnmp/mysql-<span class="number">5.6</span>.<span class="number">37</span>/data/mysql-slow.log</span><br><span class="line"><span class="attr">performance_schema</span> = <span class="number">0</span></span><br><span class="line">explicit_defaults_for_timestamp</span><br><span class="line"><span class="comment">#不区分大小写</span></span><br><span class="line"><span class="comment">#lower_case_table_names = 1 </span></span><br><span class="line"><span class="comment">#MySQL选项以避免外部锁定。该选项默认开启</span></span><br><span class="line">skip-external-locking </span><br><span class="line"><span class="comment">#默认存储引擎</span></span><br><span class="line"><span class="attr">default-storage-engine</span> = InnoDB </span><br><span class="line"><span class="attr">innodb_file_per_table</span> = <span class="number">1</span></span><br><span class="line"><span class="comment"># InnoDB为独立表空间模式，每个数据库的每个表都会生成一个数据空间</span></span><br><span class="line"><span class="comment"># 独立表空间优点：</span></span><br><span class="line"><span class="comment"># 1．每个表都有自已独立的表空间。</span></span><br><span class="line"><span class="comment"># 2．每个表的数据和索引都会存在自已的表空间中。</span></span><br><span class="line"><span class="comment"># 3．可以实现单表在不同的数据库中移动。</span></span><br><span class="line"><span class="comment"># 4．空间可以回收（除drop table操作处，表空不能自已回收）</span></span><br><span class="line"><span class="comment"># 缺点：</span></span><br><span class="line"><span class="comment"># 单表增加过大，如超过100G</span></span><br><span class="line"><span class="comment"># 结论：</span></span><br><span class="line"><span class="comment"># 共享表空间在Insert操作上少有优势。其它都没独立表空间表现好。当启用独立表空间时，请合理调整：innodb_open_files</span></span><br><span class="line"><span class="attr">innodb_open_files</span> = <span class="number">500</span></span><br><span class="line"><span class="comment"># 限制Innodb能打开的表的数据，如果库里的表特别多的情况，请增加这个。这个值默认是300</span></span><br><span class="line"><span class="attr">innodb_buffer_pool_size</span> = <span class="number">64</span>M</span><br><span class="line"><span class="comment"># InnoDB使用一个缓冲池来保存索引和原始数据, 不像MyISAM.</span></span><br><span class="line"><span class="comment"># 这里你设置越大,你在存取表里面数据时所需要的磁盘I/O越少.</span></span><br><span class="line"><span class="comment"># 在一个独立使用的数据库服务器上,你可以设置这个变量到服务器物理内存大小的80%</span></span><br><span class="line"><span class="comment"># 不要设置过大,否则,由于物理内存的竞争可能导致操作系统的换页颠簸.</span></span><br><span class="line"><span class="comment"># 注意在32位系统上你每个进程可能被限制在 2-3.5G 用户层面内存限制,</span></span><br><span class="line"><span class="comment"># 所以不要设置的太高.</span></span><br><span class="line"><span class="attr">innodb_write_io_threads</span> = <span class="number">4</span></span><br><span class="line"><span class="attr">innodb_read_io_threads</span> = <span class="number">4</span></span><br><span class="line"><span class="comment"># innodb使用后台线程处理数据页上的读写 I/O(输入输出)请求,根据你的 CPU 核数来更改,默认是4</span></span><br><span class="line"><span class="comment"># 注:这两个参数不支持动态改变,需要把该参数加入到my.cnf里，修改完后重启MySQL服务,允许值的范围从 1-64</span></span><br><span class="line"><span class="attr">innodb_thread_concurrency</span> = <span class="number">0</span></span><br><span class="line"><span class="comment"># 默认设置为 0,表示不限制并发数，这里推荐设置为0，更好去发挥CPU多核处理能力，提高并发量</span></span><br><span class="line"><span class="attr">innodb_purge_threads</span> = <span class="number">1</span></span><br><span class="line"><span class="comment"># InnoDB中的清除操作是一类定期回收无用数据的操作。在之前的几个版本中，清除操作是主线程的一部分，这意味着运行时它可能会堵塞其它的数据库操作。</span></span><br><span class="line"><span class="comment"># 从MySQL5.5.X版本开始，该操作运行于独立的线程中,并支持更多的并发数。用户可通过设置innodb_purge_threads配置参数来选择清除操作是否使用单</span></span><br><span class="line"><span class="comment"># 独线程,默认情况下参数设置为0(不使用单独线程),设置为 1 时表示使用单独的清除线程。建议为1</span></span><br><span class="line"><span class="attr">innodb_flush_log_at_trx_commit</span> = <span class="number">2</span></span><br><span class="line"><span class="comment"># 0：如果innodb_flush_log_at_trx_commit的值为0,log buffer每秒就会被刷写日志文件到磁盘，提交事务的时候不做任何操作（执行是由mysql的master thread线程来执行的。</span></span><br><span class="line"><span class="comment"># 主线程中每秒会将重做日志缓冲写入磁盘的重做日志文件(REDO LOG)中。不论事务是否已经提交）默认的日志文件是ib_logfile0,ib_logfile1</span></span><br><span class="line"><span class="comment"># 1：当设为默认值1的时候，每次提交事务的时候，都会将log buffer刷写到日志。</span></span><br><span class="line"><span class="comment"># 2：如果设为2,每次提交事务都会写日志，但并不会执行刷的操作。每秒定时会刷到日志文件。要注意的是，并不能保证100%每秒一定都会刷到磁盘，这要取决于进程的调度。</span></span><br><span class="line"><span class="comment"># 每次事务提交的时候将数据写入事务日志，而这里的写入仅是调用了文件系统的写入操作，而文件系统是有 缓存的，所以这个写入并不能保证数据已经写入到物理磁盘</span></span><br><span class="line"><span class="comment"># 默认值1是为了保证完整的ACID。当然，你可以将这个配置项设为1以外的值来换取更高的性能，但是在系统崩溃的时候，你将会丢失1秒的数据。</span></span><br><span class="line"><span class="comment"># 设为0的话，mysqld进程崩溃的时候，就会丢失最后1秒的事务。设为2,只有在操作系统崩溃或者断电的时候才会丢失最后1秒的数据。InnoDB在做恢复的时候会忽略这个值。</span></span><br><span class="line"><span class="comment"># 总结</span></span><br><span class="line"><span class="comment"># 设为1当然是最安全的，但性能页是最差的（相对其他两个参数而言，但不是不能接受）。如果对数据一致性和完整性要求不高，完全可以设为2，如果只最求性能，例如高并发写的日志服务器，设为0来获得更高性能</span></span><br><span class="line"><span class="attr">innodb_log_buffer_size</span> = <span class="number">2</span>M</span><br><span class="line"><span class="comment"># 此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，但意外的故障将会丢失数据。MySQL开发人员建议设置为1－8M之间</span></span><br><span class="line"><span class="attr">innodb_log_file_size</span> = <span class="number">32</span>M</span><br><span class="line"><span class="comment"># 此参数确定数据日志文件的大小，更大的设置可以提高性能，但也会增加恢复故障数据库所需的时间</span></span><br><span class="line"><span class="attr">innodb_log_files_in_group</span> = <span class="number">3</span></span><br><span class="line"><span class="comment"># 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3</span></span><br><span class="line"><span class="attr">innodb_max_dirty_pages_pct</span> = <span class="number">90</span></span><br><span class="line"><span class="comment"># innodb主线程刷新缓存池中的数据，使脏数据比例小于90%</span></span><br><span class="line"><span class="attr">innodb_lock_wait_timeout</span> = <span class="number">120</span> </span><br><span class="line"><span class="comment"># InnoDB事务在被回滚之前可以等待一个锁定的超时秒数。InnoDB在它自己的锁定表中自动检测事务死锁并且回滚事务。InnoDB用LOCK TABLES语句注意到锁定设置。默认值是50秒</span></span><br><span class="line"><span class="attr">bulk_insert_buffer_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="comment"># 批量插入缓存大小， 这个参数是针对MyISAM存储引擎来说的。适用于在一次性插入100-1000+条记录时， 提高效率。默认值是8M。可以针对数据量的大小，翻倍增加。</span></span><br><span class="line"><span class="attr">myisam_sort_buffer_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="comment"># MyISAM设置恢复表之时使用的缓冲区的尺寸，当在REPAIR TABLE或用CREATE INDEX创建索引或ALTER TABLE过程中排序 MyISAM索引分配的缓冲区</span></span><br><span class="line"><span class="attr">myisam_max_sort_file_size</span> = <span class="number">10</span>G</span><br><span class="line"><span class="comment"># 如果临时文件会变得超过索引，不要使用快速排序索引方法来创建一个索引。注释：这个参数以字节的形式给出</span></span><br><span class="line"><span class="attr">myisam_repair_threads</span> = <span class="number">1</span></span><br><span class="line"><span class="comment"># 如果该值大于1，在Repair by sorting过程中并行创建MyISAM表索引(每个索引在自己的线程内) </span></span><br><span class="line"><span class="attr">interactive_timeout</span> = <span class="number">28800</span></span><br><span class="line"><span class="comment"># 服务器关闭交互式连接前等待活动的秒数。交互式客户端定义为在mysql_real_connect()中使用CLIENT_INTERACTIVE选项的客户端。默认值：28800秒（8小时）</span></span><br><span class="line"><span class="attr">wait_timeout</span> = <span class="number">28800</span></span><br><span class="line"><span class="comment"># 服务器关闭非交互连接之前等待活动的秒数。在线程启动时，根据全局wait_timeout值或全局interactive_timeout值初始化会话wait_timeout值，</span></span><br><span class="line"><span class="comment"># 取决于客户端类型(由mysql_real_connect()的连接选项CLIENT_INTERACTIVE定义)。参数默认值：28800秒（8小时）</span></span><br><span class="line"><span class="comment"># MySQL服务器所支持的最大连接数是有上限的，因为每个连接的建立都会消耗内存，因此我们希望客户端在连接到MySQL Server处理完相应的操作后，</span></span><br><span class="line"><span class="comment"># 应该断开连接并释放占用的内存。如果你的MySQL Server有大量的闲置连接，他们不仅会白白消耗内存，而且如果连接一直在累加而不断开，</span></span><br><span class="line"><span class="comment"># 最终肯定会达到MySQL Server的连接上限数，这会报'too many connections'的错误。对于wait_timeout的值设定，应该根据系统的运行情况来判断。</span></span><br><span class="line"><span class="comment"># 在系统运行一段时间后，可以通过show processlist命令查看当前系统的连接状态，如果发现有大量的sleep状态的连接进程，则说明该参数设置的过大，</span></span><br><span class="line"><span class="comment"># 可以进行适当的调整小些。要同时设置interactive_timeout和wait_timeout才会生效。</span></span><br><span class="line"><span class="section">[mysqldump]</span></span><br><span class="line">quick</span><br><span class="line"><span class="comment">#服务器发送和接受的最大包长度</span></span><br><span class="line"><span class="attr">max_allowed_packet</span> = <span class="number">16</span>M </span><br><span class="line"><span class="section">[myisamchk]</span></span><br><span class="line"><span class="attr">key_buffer_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="attr">sort_buffer_size</span> = <span class="number">8</span>M</span><br><span class="line"><span class="attr">read_buffer</span> = <span class="number">4</span>M</span><br><span class="line"><span class="attr">write_buffer</span> = <span class="number">4</span>M</span><br></pre></td></tr></table></figure><p>这些配置在默认生成的文件中都没有，mysql支持启动时设置参数。</p><h3 id="4-3-启动"><a href="#4-3-启动" class="headerlink" title="4.3 启动"></a>4.3 启动</h3><p>对于mysql的启动，方式比较多</p><p><strong>mysqld_safe启动</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/lnmp/mysql-5.6.37/bin/mysqld_safe --user=mysql</span><br></pre></td></tr></table></figure><p><strong>mysqld启动</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/lnmp/mysql-5.6.37/bin/mysqld --user=mysql --explicit_defaults_for_timestamp</span><br></pre></td></tr></table></figure><p><strong>init.d启动</strong>：需要将support-files/mysql.server拷贝到/etc/init.d/mysql.server</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp support-files/mysql.server /etc/init.d/mysql.server</span><br><span class="line">/etc/init.d/mysql.server [start|stop|restart|reload|force-reload|status]</span><br></pre></td></tr></table></figure><h2 id="5-PHP安装"><a href="#5-PHP安装" class="headerlink" title="5 PHP安装"></a>5 PHP安装</h2><h3 id="5-1-编译安装"><a href="#5-1-编译安装" class="headerlink" title="5.1 编译安装"></a>5.1 编译安装</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压源文件</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/lnmp/src</span><br><span class="line">tar -zxf php-5.5.38.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> php-5.5.38</span><br><span class="line"><span class="comment">#配置编译选项（这里默认编译pdo，fpm，mysql模块，更多编译选项可以通过configure --help 查看）</span></span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/lnmp/php-5.5.38 --<span class="built_in">enable</span>-fpm --<span class="built_in">enable</span>-mysqlnd --with-mysql --with-mysqli --with-pdo-mysql</span><br><span class="line"></span><br><span class="line">make </span><br><span class="line"><span class="comment">#make完成后，会提示进行make test，这一步可以不做，但是建议做一下</span></span><br><span class="line">make <span class="built_in">test</span> </span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h3 id="5-2-配置PHP"><a href="#5-2-配置PHP" class="headerlink" title="5.2 配置PHP"></a>5.2 配置PHP</h3><pre><code>PHP配置包括两部分，一部分是fpm的配置，因为我们nginx和php进行交互是采用fpm的形式进行的；另一部分为php.ini，php全局配置。php.ini去源码目录拷贝一份便可。</code></pre><p><strong>php.ini</strong></p><p>存放目录：/usr/local/lnmp/php-5.5.38/lib，基本上安装完毕，拷贝到此目录基本不需要修改即可运行，这里我们简单罗列一些基本的配置。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[PHP]</span></span><br><span class="line"><span class="comment">; 输出缓存允许你甚 在输出正 内容之后发送 header(标头，包括cookies)    ; 或者在这 将指示设为 On  使得所有 件的输出缓存打开。</span></span><br><span class="line"><span class="attr">output_buffering</span> = <span class="literal">Off</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">; 强制flush(刷新)让PHP 告诉输出层在每个输出块之后 动刷新 身数据，建议仅在debug过程中打开。</span></span><br><span class="line"><span class="attr">implicit_flush</span> = <span class="literal">Off</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">; 每个脚本的最 执 时间, 按秒计</span></span><br><span class="line"><span class="attr">max_execution_time</span> = <span class="number">30</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">; 个脚本最多可使的内存总大小(这里是8MB)</span></span><br><span class="line"><span class="attr">memory_limit</span> = <span class="number">1024</span> </span><br><span class="line"></span><br><span class="line"><span class="section">[Date]</span></span><br><span class="line">date.timezone =Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment">; E_ALL - 所有的错误和警告  </span></span><br><span class="line"><span class="comment">; E_ERROR - 致命性运 时错  </span></span><br><span class="line"><span class="comment">; E_WARNING - 运 时警告( 致命性错)  </span></span><br><span class="line"><span class="comment">; E_PARSE - 编译时解析错误  </span></span><br><span class="line"><span class="comment">; E_NOTICE - 运 时提醒</span></span><br><span class="line"><span class="comment">; error_reporting = E_ALL &amp; ~E_NOTICE ; 显示所有的错误，除 提醒  </span></span><br><span class="line"><span class="comment">; error_reporting = E_COMPILE_ERROR|E_ERROR|E_CORE_ERROR ; 仅显示错 误 </span></span><br><span class="line"><span class="comment">; 显示所有的错误，除了提醒  </span></span><br><span class="line"><span class="attr">error_reporting</span> = E_ALL &amp; ~E_NOTICE </span><br><span class="line"><span class="comment">; 显示出错误信息(作为输出的一部分)</span></span><br><span class="line"><span class="attr">display_errors</span> = <span class="literal">On</span></span><br><span class="line"><span class="attr">log_errors</span> = <span class="literal">Off</span></span><br><span class="line"><span class="attr">error_log</span> = logs/error.log</span><br><span class="line"><span class="attr">default_mimetype</span> = <span class="string">"text/html"</span></span><br><span class="line"><span class="comment">;default_charset = "iso-8859-1"</span></span><br><span class="line"><span class="comment">; 存放可加载的扩充库(模块)的 录</span></span><br><span class="line"><span class="attr">extension_dir</span> = <span class="string">"./"</span></span><br><span class="line"><span class="comment">;extension=msql.so</span></span><br><span class="line"><span class="comment">; 这条指示告诉PHP是否声明argv和argc变量数 (注:这 argv为数组,argc为变量数)</span></span><br><span class="line"><span class="attr">register_argc_argv</span>=<span class="literal">On</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; PHP将接受的POST数据最大大小。</span></span><br><span class="line"><span class="attr">post_max_size</span> = <span class="number">8</span>M</span><br><span class="line"></span><br><span class="line"><span class="comment">; 是否允许HTTP方式文件上载</span></span><br><span class="line"><span class="attr">file_uploads</span> = <span class="literal">On</span> </span><br><span class="line"><span class="comment">; 存放用HTTP协议上载的文件的临时目录(在没指定时使用系统默认的)</span></span><br><span class="line"><span class="attr">upload_tmp_dir</span> = /tmp</span><br><span class="line"><span class="attr">upload_max_filesize</span> = <span class="number">2</span>M </span><br><span class="line"><span class="section">[Session]</span>  </span><br><span class="line"><span class="comment">; 于保存/取回数据的控制方式   </span></span><br><span class="line">session.save_handler = files</span><br><span class="line"><span class="comment">; 这是数据文件将保存的路径   </span></span><br><span class="line">session.save_path = /tmp</span><br><span class="line"><span class="comment">; 是否使用cookies  </span></span><br><span class="line">session.use_cookies = 1</span><br><span class="line">session.name = PHPSESSID</span><br><span class="line"><span class="comment">; 在请求启动时初始化session</span></span><br><span class="line">session.auto_start = 0 </span><br><span class="line"><span class="comment">; 为按秒记的cookie的保存时间,或为0时,直到浏览器被重启  </span></span><br><span class="line">session.cookie_lifetime = 0 </span><br><span class="line"><span class="comment">; cookie的有效路径  </span></span><br><span class="line">session.cookie_path = / </span><br><span class="line"><span class="comment">; cookie的有效域</span></span><br><span class="line">session.cookie_domain = </span><br><span class="line"><span class="comment">; 于连接数据的控制器; php是PHP的标准控制器</span></span><br><span class="line">session.serialize_handler = php </span><br><span class="line"><span class="comment">; 按百分 的'garbage collection(碎 整 )'进程  </span></span><br><span class="line">session.gc_probability = 1 </span><br><span class="line"><span class="comment">; 在每次 session 初始化的时候开始的可能性。  </span></span><br><span class="line"><span class="comment">; 在这里数字所指的秒数后，保存的数据将被视为'碎片(garbage)'并由gc进程清理掉</span></span><br><span class="line">session.gc_maxlifetime = 1440</span><br><span class="line"><span class="comment">; 设为&#123;nocache,private,public&#125;,以决定HTTP的缓存的问题  </span></span><br><span class="line">session.cache_limiter = nocache </span><br><span class="line"><span class="comment">; 文档在n分钟后过时</span></span><br><span class="line">session.cache_expire = 180</span><br></pre></td></tr></table></figure><p><strong>php-fpm.conf</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">pid</span> = run/php-fpm.pid</span><br><span class="line"><span class="attr">error_log</span> = log/php-fpm.log</span><br><span class="line"></span><br><span class="line"><span class="comment">; Possible Values: alert, error, warning, notice, debug</span></span><br><span class="line"><span class="attr">log_level</span> = notice</span><br><span class="line"><span class="attr">emergency_restart_interval</span> = <span class="number">0</span></span><br><span class="line"><span class="attr">process_control_timeout</span> = <span class="number">0</span></span><br><span class="line">process.max = 128</span><br><span class="line"><span class="comment">;process.priority = -19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; php-fpm运行模式，默认为后台运行</span></span><br><span class="line"><span class="attr">daemonize</span> = <span class="literal">yes</span></span><br><span class="line"><span class="comment">;rlimit_core = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; fpm使用的事件驱动模型，默认没有设置，进行自动选择</span></span><br><span class="line"><span class="comment">;events.mechanism = epoll</span></span><br><span class="line"><span class="section">[www]</span></span><br><span class="line"><span class="attr">user</span> = www</span><br><span class="line"><span class="attr">group</span> = www</span><br><span class="line"><span class="attr">listen</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9000</span></span><br><span class="line"><span class="comment">;listen.backlog = 65535</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 设置允许链接的客户端IP，默认为任何</span></span><br><span class="line"><span class="comment">;listen.allowed_clients = 127.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 子进程控制模式，分为三种：</span></span><br><span class="line"><span class="comment">; static固定模式：子进程数一直等于pm.max_children</span></span><br><span class="line"><span class="comment">; dynamic动态模式：其子进程数量根据max_children、start_servers、min_spare_servers、max_spare_servers决定，但至少会有一个存在</span></span><br><span class="line"><span class="comment">; ondemand按需型：当请求来时才创建，最大存在数取决于max_children，process_idle_timeout指令表示空闲指定时间后退出</span></span><br><span class="line"><span class="attr">pm</span> = dynamic</span><br><span class="line"></span><br><span class="line"><span class="comment">; 最大子进程数</span></span><br><span class="line">pm.max_children = 5</span><br><span class="line"></span><br><span class="line"><span class="comment">; 启动时创建的子进程数，默认值为min_spare_servers + (max_spare_servers - min_spare_servers) / 2</span></span><br><span class="line">pm.start_servers = 2</span><br><span class="line">pm.min_spare_servers = 1</span><br><span class="line">pm.max_spare_servers = 3</span><br><span class="line"><span class="comment">;pm.process_idle_timeout = 500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 处理完多少个请求后重启</span></span><br><span class="line"><span class="comment">;pm.max_requests = 500</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 请求日志记录文件</span></span><br><span class="line"><span class="comment">;access.log = log/$pool.access.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 请求日志文件格式</span></span><br><span class="line"><span class="comment">;access.format = "%R - %u %t \"%m %r%Q%q\" %s %f %&#123;mili&#125;d %&#123;kilo&#125;M %C%%"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 慢日志</span></span><br><span class="line"><span class="comment">;slowlog = log/$pool.log.slow</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;request_slowlog_timeout = 0</span></span><br><span class="line"><span class="comment">;request_terminate_timeout = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 打开文件数，默认为系统上限</span></span><br><span class="line"><span class="comment">;rlimit_files = 1024</span></span><br></pre></td></tr></table></figure><h2 id="6-遇到的问题"><a href="#6-遇到的问题" class="headerlink" title="6 遇到的问题"></a>6 遇到的问题</h2><h3 id="6-1-nginx到php"><a href="#6-1-nginx到php" class="headerlink" title="6.1 nginx到php"></a>6.1 nginx到php</h3><blockquote><p><strong>问题描述：</strong>2017/08/12 23:27:22 [error] 13752#0: *10 FastCGI sent in stderr: “Primary script unknown” while reading response header from upstream, client: 127.0.0.1, server: localhost, request: “GET /index.php HTTP/1.1”, upstream: “fastcgi://127.0.0.1:9000”, host: “127.0.0.1:9091”</p></blockquote><p>这里的问题是nginx配置里到fpm的代理配置有问题：</p><blockquote><p>fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</p></blockquote><p>将此处修改为</p><blockquote><p>fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;</p></blockquote><p><strong>说明：</strong></p><blockquote><p>$document_root 代表当前请求在root指令中指定的值，上面配置中的$document_root就是针对/data0/www/htdocs/lnmp.com目录下的php文件进行解析</p></blockquote><h3 id="6-2-其他问题"><a href="#6-2-其他问题" class="headerlink" title="6.2 其他问题"></a>6.2 其他问题</h3><p>在安装过程中若遇到其他问题，均可以根据错误提示信息找到答案，google、百度都可以帮助你解决问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    作为一个PHPer，没有手动搭过几次LNMP环境，都不算是一个真正的PHPer。此文主要以实际着手搭建一套lnmp环境为主线，介绍其中涉及到的技术点。包括php配置、php-fpm配置、nginx配置、mysql配置。以及这他们之间的关系。&lt;/p&gt;
    
    </summary>
    
      <category term="LNMP/env/01" scheme="/categories/LNMP-env-01/"/>
    
      <category term="lnmp/envrionment" scheme="/categories/LNMP-env-01/lnmp-envrionment/"/>
    
    
      <category term="PHP" scheme="/tags/PHP/"/>
    
      <category term="Nginx" scheme="/tags/Nginx/"/>
    
      <category term="Linux" scheme="/tags/Linux/"/>
    
      <category term="MySQL" scheme="/tags/MySQL/"/>
    
      <category term="LNMP" scheme="/tags/LNMP/"/>
    
  </entry>
  
</feed>
